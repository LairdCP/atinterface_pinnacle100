// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Copyright (c) 2017, Laird Connectivity                                     ++
//                                                                            ++
// Permission to use, copy, modify, and/or distribute this software for any   ++
// purpose with or without fee is hereby granted, provided that the above     ++
// copyright notice and this permission notice appear in all copies.          ++
//                                                                            ++
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES   ++
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF           ++
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR    ++
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES     ++
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN      ++
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR ++
// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.                ++
//                                                                            ++
// SPDX-License-Identifier:ISC                                                ++
//                                                                            ++
// ************************************************************************** ++
// A smartBASIC library that exposes an AT Interface to control a VSP         ++
// or non-VSP connection and advertise or scan that will run on a Laird       ++
// Connectivity module with the following compile time optional features:-    ++
//    + AT+GCTM command enabled to query peer's GATT table schema             ++
//    + If error handler called then module will reset and restart            ++
//    + VSP Overrun Event is enabled when there is a VSP incoming overrun     ++
//    + Long Range Connection capability enabled                              ++
//    + NFC related commands enabled                                          ++
//    + Low Power Uart operation - port closed when there is no activity      ++
// ************************************************************************** ++
//                                                                            ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminalX downloads the app to the module it will be saved   ++
// +++++  as a file with filename $autorun$ which means it will run           ++
// +++++  automatically on reset.                                             ++
// +++++  The File System can be queried using the command AT+DIR             ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// -------------------
// ATinterface Library Version
// -------------------
#define LibVer                 "1.20"  //Library version  (ATI23)
//
//******************************************************************************
// Compiler/Debug options
//******************************************************************************
//   ======================================================
//   Conditional Compile Masks (they can be additive)
//   ------------------------------------------------------
//
// Higher 16 bits used for feature set
//   0x00000000 :
//
// Lower 16 bits used for debugging (Collectively == DebugMessages)
//   0x00000001 : Enable debugging messages
//   0x00000002 : Enable Asserts printed out of UART
//   0x00000004 : Enable DbgXXX messages
//   0x00000008 : Enable Conn Parameters display
//   0x00000010 : Enable PHY Change debugging (+PHYchng)
//   0x00000020 : Enable Multiplexer State debug display
//   0x00000040 : Enable VSP MDM change activity for debugging (+MDMCHNG)
//   0x00000080 : Enable VSPRXOVRN debug print
//   0x00000100 : Enable low power UART debugging
//   0x00000200 :
//   0x00000400 : Enable printing of all adverts for debugging
//   0x00000800 : Enable AuxBreak Handler
//   0x00001000 :
//   0x00002000 :
//   0x00004000 : Enable S Register interface debugging
//   0x00008000 : Enable arg parsing prints
//
// Upper 16 bits for features (Collectively == AllFeatures)
//   0x00010000 : Include Verbose Code for setting defaults (VerboseDefRegisterCreation)
//   0x00020000 : Enable TableMap command AT+GCTM
//   0x00040000 : On ERROR call reset
//   0x00080000 : Enable the EVVSPRXOVRN event handler  +VSPOVRN
//   0x00100000 : Enable Long Range Capability  +LRANGE
//   0x00200000 : Enable NFC    +NFC
//   0x00400000 :
//   0x00800000 : Send a <DEL> chr for each ! in Mode 1 when escaping back
//   0x01000000 :
//   0x02000000 : Use HlSleeping variable to influence UART low power operation
//   0x04000000 : Suppress 'bt' prefix in Modes 0 and 1
//   0x08000000 : AUX_RTS/AUX_TXD configured for S0D1 type output to prevent leakage
//   0x10000000 : Do not relocate autorun pin
//   0x20000000 : On start print version
//   0x40000000 : Cellular Module - Aux Uart Pins to alternate SIO
//   0x80000000 : Cellular Module
//   ======================================================
// -------------------
// Application History
// -------------------
//
//  1.20 (30 Sep 2019)
//    * Xtal based HFLCK is enabled when any of the UART is opened and closed
//      when both are closed.
//
//  1.10 (20 Sep 2019)
//    * Added GPIO6 sense logic
//    * Added "VG:" async response when VGPIO changes when mux to 840
//    * Added "G2:" async response when GPIO2 changes when mux to 840
//    * Added "G6:" async response when GPIO6 changes when mux to 840
//    * Added "DS:" async response when UART1_DSR changes when mux to 840
//    * Added "AX:" async response when Rx data at AUX port and mux to 840
//
//  1.06 (1 Jul 2019)
//    * AUX_TX and AUX_RTS are S0D1 when VGPIO = 0 and S0S1 when VGPIO = 1
//        Firmware required is 120.3.3.23 or newer
//
//  1.05 (25 Jun 2019)
//    * AUX_TX and AUX_RTS are S0D1 configuration now compile dependent - 0x08000000
//
//  1.04 (25 Jun 2019)
//    * AUX_TX and AUX_RTS are configured as SOD1 so that when VGPIO drops to 0v
//      on HL78 there is no 0.2v on it through leakage.
//    * WAKE_UP pin to HK78 is now initialised to 1 and not 0 (Bug 14744)
//
//  1.03 (20 Jun 2019)
//    * Added AT+TEMP command which returns the 840 chip temperature which is
//      accurate to +/- 10%
//
//  1.02 (17 Jun 2019)
//    * Added AT+FUP command to enter bootloader
//
//  1.01 (13 Jun 2019)
//    * When SIO_LTE_GPIO2 is initialised as an input, it is now configured so that
//      it has a pulldown resistor as per the Sierra documentation
//
//  1.00 (13 Jun 2019)
//    * Candidate release
//
//  0.910 (8 May 2019)
//    * Tweaks to make the app compatible with v4 of modem and v3 of devkit
//
//  0.909
//    * AT+CFG 120 format changed so that any GPIO pin and assert state can be
//      specified and now we set the value to 0x128 (pin 40, assert high)
//
//  0.908
//    * Version number change
//    * Default MuxMode is now 1 because MUX_CNTL can be used in addition
//    * Added monitoring of VGPIO/GPIO2/UART1_DSR lines from HL
//    * Added state machine post reset to detect when HL ready and then send CM: response to host
//
//  0.907
//    * Disallow AT! in mode 1 when there is a VSP connection
//    * Disallow at commands from UART in mode 2 when there is a VSP connection.
//    * On VSP connection, force UART to 840 as VSP has the Auxport
//    * In Mux Mode 1 a lo-hi transition on MUX_CTRL flips the direction
//
//  0.905
//    * Disallow VSP for AT+LVSP command
//    * On Startup disallow VSP registering in GATT if mux mode 0
//
//  0.903
//    * Added SReg124 to force reset of HL78 on startup. Default is enabled to reset
//
//  0.901
//    * Version change and deployed to O365
//    * With this in PSM mode we can get as low as 115uA
//    * Added code to change autorun pin to BUTTON3 which is on P1.08
//
//  0.891
//    * On Aux close, config all rx/tx/cts/rts as inputs with no pull resistors
//    * When main UART is closed, all 4 lines are inputs with no pull resistors - current down to 270
//    * Added sb app variants that can be loaded into a BL654 devkit
//    * Print a message on start-up which includes the versions
//    * Lowpower mode mux pin is configured with no-pulls
//    * Ensure UartFlush and AuxFLush are not called if they are not open
//    * OnError handler now always prints a message before resetting
//    * On start-up nAutorun pin is reconfigured as an input with no pull
//    * Suppress printing of OK on startup
//
//  0.890
//    * HL related i/o initialised as early as possible
//    * Reset LTE on app start (for 50ms)
//    * WAKEUP initialised as output - init low
//    * DTR output is now S0D1 so disconnected when high - so safe to de-assert at any time
//    * Added AT+ASLP command (undocumented)
//    * Added AT43 which returns the states of the 5 output lines to HL - format "Dn Pn Wn Fn Rn"
//    * Bug fix: ATI0 was not working when in mode 0
//    * allow 'bt' prefix in all modes
//    * Enabled NFC functionality
//
//  0.87
//    * Low power UART operation
//
//  0.84
//    * Default Mux Mode is 0 and added AT commands to control
//      output pins to HL and also another command to monitor
//      transitions of the 2 inputs pins from the HL
//
//  0.83
//    * Enable CTS events when AUX is opened
//
//  0.80
//    * Forked from BL65x ATinterface app for Pinnacle
//
//******************************************************************************

//******************************************************************************
// Definitions
//******************************************************************************

//------------------------------------------------------------------------------
//It is NOT recommended that the following be modified for customisation - do so with
//care, and it is suggested it is fed back to Laird Connectivity to ease your maintenance in
//the future if Laird Connectivity modifies and enhances this application
//------------------------------------------------------------------------------

//This defines the maximum number of UUID handles
#define MAX_UUID_HANDLES                          16

//This defines the maximum number of elements in metadata array
#define MAX_METADATA_HANDLES                      4

//Maximum comma separated arguments allowed in an AT command
#define MAX_ARGS_IN_ATCMD                         10

//Laird Connectivity service UUID to advertise
#define LAIRD_UUID_LTE_SERVICE                    0x1101

//ASCII characters
#define CHR_ASCII_SPACE                           0x20
#define CHR_ASCII_H                               0x48
#define CHR_ASCII_N                               0x4E

//Invalid connection handle
#define INVALID_CONN_HANDLE                       0

//Invalid UUID handle
#define INVALID_UUID_HANDLE                       -1

//Index for the handle for the VSP connection
#define HCONN_VSP                                 0

//Timer used for encryption timeout
#define TMRNUM_DATA_PUMP                          0
#define   EVTMR_DATA_PUMP                           EVTMR0
#define TMRNUM_ESCAPE_DELAY                       1
#define   EVTMR_ESCAPE_DELAY                        EVTMR1
#define TMRNUM_ENCR_WAIT                          2
#define   EVTMR_ENCR_WAIT                           EVTMR2
#define TMRNUM_LOWPWR_UARTandAUX                  3
#define   EVTMR_LOWPWR_UARTandAUX                   EVTMR3
#define TMRNUM_HLSTATE_TRACK                      4
#define   EVTMR_HLSTATE_TRACK                       EVTMR4
#define TMRNUM_TEMPERATURE_CHECK                  5
#define   EVTMR_TEMPERATURE_CHECK                   EVTMR5

//Maximum length of attribute length in metadata when creating GATT table
#define MAX_ATTRIBUTE_LEN                         250


//AT Command letter
#define ATCMD_EMPTY                               0
#define ATCMD_D                                   0x44
#define ATCMD_F                                   0x46
#define ATCMD_H                                   0x48
#define ATCMD_I                                   0x49
#define ATCMD_S                                   0x53
#define ATCMD_W                                   0x57
#define ATCMD_X                                   0x58
#define ATCMD_Z                                   0x5A
#define ATCMD_PERCENT                             0x25
#define ATCMD_AMPERSAND                           0x26
#define ATCMD_PLUS                                0x2B
#define ATCMD_EXCLAMATION                         0x21

//AT Responses for VSP connect ( starts at 80 because HSI reason is up to 64 )
#define CONN_OK                                     0
#define CONN_ERROR_BLECONNECT                       80
#define CONN_ERROR_INVALID_ADDRESS                  81
#define CONN_ERROR_CMDPINSTATE                      82
#define CONN_ERROR_TOOMANYCONNECTIONS               83
#define CONN_ERROR_TIMEOUT                          84
#define CONN_ERROR_OUTOFMEM                         85
#define CONN_ERROR_UNENCRYPTED                      86
#define CONN_ERROR_NOVSPSERVICE                     87
#define CONN_ERROR_PAIRUI                           88
#define CONN_ERROR_USER_DISCON                      90
#define CONN_ERROR_AUTHLINK_REQUIRED                91
#define CONN_ERROR_MUXMODE_INCORRECT                92
#define CONN_SUSPEND                                -1

//Types of adverts
#define ADV_IND                                     0
#define ADV_DIRECT_IND                              1
#define ADV_SCAN_IND                                2
#define ADV_NONCONN_IND                             3

//Bonding KeyInfo
#define BONDING_KEYINFO_MITM_AUTHENTICATED          1
#define BONDING_KEYINFO_AUTO_DELETE_ROLLING         2
#define BONDING_KEYINFO_IRK_EXISTS                  4
#define BONDING_KEYINFO_CSRK_EXISTS                 8
#define BONDING_KEYINFO_LTK_AS_SLAVE_EXISTS         16
#define BONDING_KEYINFO_LTK_AS_MASTER_EXISTS        32

//Bond trust context
#define BOND_TRUSTED_AS_PERIPHERAL                  0
#define BOND_TRUSTED_AS_CENTRAL                     1

//MITM requirement bit masks
#define BLE_ENCRYPT_MITM_NOT_REQUIRED               0
#define BLE_ENCRYPT_MITM_REQUIRED                   1

// Minimum LTK size requirement
#define LTK_MINIMUM_SIZE                            7

//Values in curState variable
#define STATE_INIT                                  0
#define STATE_IDLE_nonVSP                           10
#define STATE_IDLE_VSP                              20
#define STATE_SCAN_VSP                              30
#define STATE_VSP_PATCH_CONNECTED                   40
#define STATE_VSP_CONNECTING_OUTGOING               50
#define STATE_VSP_WAIT_ENCRYPT                      51
#define STATE_VSP_GET_HANDLES                       52
#define STATE_VSP_WRITE_CCCDS                       53
#define STATE_VSP_PAIRING                           54
#define STATE_VSP_DISCONNECTING                     55
#define STATE_VSP_IGNORED                           56
#define STATE_nonVSP_CONNECTING                     60
#define STATE_nonVSP_CONNECTED                      80
#define STATE_VSP_IN_WAIT_ENCR                      70

//Define states for HL to track
#define HLSTATE_IN_RESET                            0x00    //does not respond to AT Commands
#define HLSTATE_POSTRESET_WAIT_VGPIO                0x01    //does not respond to AT Commands
#define HLSTATE_POSTRESET_WAIT_CTS_DEASSERT         0x02    //does not respond to AT Commands
#define HLSTATE_POSTRESET_WAIT_CTS_ASSERT           0x03    //does not respond to AT Commands
#define HLSTATE_POSTRESET_WAIT_DSR_DEASSERT         0x04    //does not respond to AT Commands
#define HLSTATE_POSTRESET_WAIT_DSR_ASSERT           0x05    //does not respond to AT Commands
#define HLSTATE_RUN                                 0x10
#define HLSTATE_SLEEP                               0x20
#define HLSTATE_LITE_HIBERNATE                      0x30
#define HLSTATE_HIBERNATE                           0x40

//MsgID for SendMsgApp so that we can serialise processes and also used
//to invoke functionality which is not compiled yet
#define MSGAPP_PROCESS_UART                         0
#define MSGAPP_ENTER_VSPOUT_CONN_STATE              1
#define MSGAPP_ENTER_VSPIN_CONN_STATE               2
#define MSGAPP_ENTER_NONVSP_CONN_STATE              3
#define MSGAPP_ENTER_MUXMODE1_HL78                  4
#define MSGAPP_ENTER_MUXMODE2_840_IDLE              5
#define MSGAPP_ENTER_MUXMODE2_HL78_BUSY             6
#define MSGAPP_ENTER_MUXMODE2_HL78_ASYNC_RSP        7
#define MSGAPP_ENTER_MUXMODE2_HL78_BUSY_RSP         8
#define MSGAPP_PROCESS_PARSER_RESUMED               9
#define NULL_CTX                                    0

//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                          0    //msgCTx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                       1    //msgCTx = connection handle
#define BLE_EVBLEMSGID_DISPLAY_PASSKEY                  9    //msgCTx = passcode to display
#define BLE_EVBLEMSGID_NEW_BOND                         10   //msgCTx = connection handle
#define BLE_EVBLEMSGID_AUTH_KEY_REQUEST                 11   //msgCTx = 1 for passkey, 2 for 16 byte OOB data
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE                14   //msgCTx = connection handle
#define BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL           15   //msgCTx = connection handle
#define BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER            16   //msgCTx = connection handle
#define BLE_EVBLEMSGID_UPDATED_BOND                     17   //msgCTx = connection handle
#define BLE_EVBLEMSGID_ENCRYPTED                        18   //msgCTx = connection handle
#define BLE_EVBLEMSGID_POWER_FAILURE_WARNING            19   //msgCTx = current supply voltage
#define BLE_EVBLEMSGID_UNENCRYPTED                      20   //msgCTx = connection handle
#define BLE_EVBLEMSGID_DEVICENAME_WRITE                 21   //msgCTx = connection handle
#define BLE_EVBLEMSGID_BOND_ADDFAIL                     22   //msgCTx = connection handle
#define BLE_EVBLEMSGID_SRVCCHNG_IND_SENT                23   //msgCTx = connection handle
#define BLE_EVBLEMSGID_SRVCCHNG_IND_CNF                 24   //msgCTx = connection handle
#define BLE_EVBLEMSGID_OOB_AVAILABLE_REQEST             25   //msgCTx = connection handle
#define BLE_EVBLEMSGID_AUTHENTICATION_FAILED            26   //msgCTx = connection handle
#define BLE_EVBLEMSGID_LESC_PAIRING                     27   //msgCTx = connection handle
#define BLE_EVBLEMSGID_LESC_OOB_REQUEST                 28   //msgCTx = connection handle

//Keytype values that arrive in message BLE_EVBLEMSGID_AUTH_KEY_REQUEST
#define BLE_GAP_AUTH_KEY_TYPE_NONE        0x00   // No key (may be used to reject)
#define BLE_GAP_AUTH_KEY_TYPE_PASSKEY     0x01   // 6-digit Passkey
#define BLE_GAP_AUTH_KEY_TYPE_OOB         0x02   // Out Of Band data

//Defines associated with UART low power operation
#define UART_SIONUM_RX                             8
#define UART_SIONUM_CTS                            7
#define UART_SIONUM_TX                             6
#define UART_SIONUM_RTS                            5
#define UART_IDLE_REPOLL_TIMEOUT_MS                1000

//These are ID's used to help with reuse of helper functions
#define CMD_I_LDSC                                 0
#define CMD_I_PAIR                                 1
#define CMD_I_LENC                                 2
#define CMD_I_GCTM                                 3
#define CMD_I_LMTU                                 4
#define CMD_I_LPHY                                 5

#define CMD_CEL_CDTR                               0
#define CMD_CEL_CPWR                               1
#define CMD_CEL_CWKU                               2
#define CMD_CEL_CFSD                               3
#define CMD_CEL_CRST                               4
#define CMD_CEL_ASLP                               8
#define CMD_CEL_CSTS                               16

#define CMD_NOPARM_CCMS                            0
#define CMD_NOPARM_TEMP                            1

#define CMD_IS_NOTIFY                              0
#define CMD_IS_INDICATE                            1
#define CMD_IS_LOCALWRITE                          2

#define DEFAULT_ATT_MTU                            23
#define DEFAULT_ATTRIBUTE_SIZE                     (DEFAULT_ATT_MTU-3)

#define ATTRIBUTE_MTU_KEY_ID                       211    // CFG ID 211
#define ATTRIBUTE_DATA_LENGTH_KEY_ID               212    // CFG ID 212
#define USE_STRINT_IN_EVENTS_KEY_ID                213    // CFG ID 213
#define ENABLE_HIGH_BANDWIDTH_KEY_ID               214    // CFG ID 214
#define BLE_MAX_PACKET_LENGTH_KEY_ID               216    // CFG ID 216
#define AUTORUN_SIO_KEY_ID                         120    //Config Key for relocating nAutorun pin

#define FALSE                                      0
#define TRUE                                       (!0)

//NFC related
#define INVALID_NFC_HANDLE                         0xFFFFFFFF
#define INVALID_NDEF_HANDLE                        0xFFFFFFFF
#define NFC_DEFAULT_TAG_SIZE                       128
#define NFC_MIN_TAG_SIZE                           128
#define NFC_MAX_TAG_SIZE                           512

#define NFC_TNF_EMPTY                             0x00 // The value indicates that there is no type or payload associated with this record.
#define NFC_TNF_WELL_KNOWN                        0x01 // NFC Forum well-known type [NFC RTD].
#define NFC_TNF_MEDIA_TYPE                        0x02 // Media-type as defined in RFC 2046 [RFC 2046].
#define NFC_TNF_ABSOLUTE_URI                      0x03 // Absolute URI as defined in RFC 3986 [RFC 3986].
#define NFC_TNF_EXTERNAL_TYPE                     0x04 // NFC Forum external type [NFC RTD].
#define NFC_TNF_UNKNOWN_TYPE                      0x05 // The value indicates that there is no type associated with this record.
#define NFC_TNF_UNCHANGED                         0x06 // The value is used for the record chunks used in chunked payload.
#define NFC_TNF_RESERVED                          0x07 // The value is reserved for future use.
#define NFC_MSGIN_NFCFIELDOFF                     2
#define NFC_MSGIN_NFCFIELDON                      3
#define NFC_MSGIN_NFCTAGREAD                      7

//SIO function values for GpioSetFunc()
#define SIOTYPE_DIN                               1
#define SIOTYPE_DOUT                              2
#define SIOTYPE_AIN                               3

#define INPUT_PULL_NONE                           0
#define INPUT_PULL_DOWN                           1
#define INPUT_PULL_UP                             2

#define DETECT_LO_TO_HI                           0
#define DETECT_HI_TO_LO                           1
#define DETECT_TOGGLE                             2

#define OUTPUT_INIT_LOW                           0
#define OUTPUT_INIT_HI                            1

// Output drive capability
//
// Disconnect = highZ when output at that level
// Standard   = current capability (0.5mA Vdd >= 1.7v)
// High       = current capability (3.0mA Vdd >= 1.7v, 5.0mA Vdd >= 2.7v)
//
//                                                         0           1
#define OUTPUT_DRIVE_S0S1                         0x00  // Standard    Standard
#define OUTPUT_DRIVE_H0S1                         0x10  // High        Standard
#define OUTPUT_DRIVE_S0H1                         0x20  // Standard    High
#define OUTPUT_DRIVE_H0H1                         0x30  // High        High
#define OUTPUT_DRIVE_D0S1                         0x40  // Disconnect  Standard
#define OUTPUT_DRIVE_D0H1                         0x50  // Disconnect  High
#define OUTPUT_DRIVE_S0D1                         0x60  // Standard    Disconnect
#define OUTPUT_DRIVE_H0D1                         0x70  // High        Disconnect

#define UART_DRIVE_CFG_S0S1                       0  // Standard    Standard
#define UART_DRIVE_CFG_H0S1                       1  // High        Standard
#define UART_DRIVE_CFG_S0H1                       2  // Standard    High
#define UART_DRIVE_CFG_H0H1                       3  // High        High
#define UART_DRIVE_CFG_D0S1                       4  // Disconnect  Standard
#define UART_DRIVE_CFG_D0H1                       5  // Disconnect  High
#define UART_DRIVE_CFG_S0D1                       6  // Standard    Disconnect
#define UART_DRIVE_CFG_H0D1                       7  // High        Disconnect

//SReg120:: Multiplexor mode value meanings
#define MULTIPLEXER_MODE_GPIO                     0
#define MULTIPLEXER_MODE_NONGPIO                  1
#define MULTIPLEXER_MODE_INTELLIGENT              2

//Multiplexer states
#define MUX_STATE_INIT                            0
#define MUX_STATE_0_840                           10
#define MUX_STATE_0_HL78                          11
#define MUX_STATE_1_840                           20
#define MUX_STATE_1_HL78_UART_IDLE                21
#define MUX_STATE_1_HL78                          22
#define MUX_STATE_2_840_IDLE                      30
#define MUX_STATE_2_HL78_ASYNC_RSP                31
#define MUX_STATE_2_HL78_BUSY                     32
#define MUX_STATE_2_840_PATCH                     33
//#define MUX_STATE_3

#define MUXMODE_1_POINT_TO_HL78                   0   //DTR assert means it is low
#define MUXMODE_1_POINT_TO_840                    1

#define MUX_ESCAPE_MAXCOUNT                       3

#define MUX_AUX_RELAY_CHUNK_LEN                   128
#define MUX_UART_RELAY_CHUNK_LEN                  64
#define MUX_AUX_MAX_TXCACHE_LEN                   128
#define MUX_RESPONSE_TYPE_MATCH_SIZE              11
#define MUX_MAX_REP_END_STRINGS                   3

//Maximum reset assert time to cellular modem
#define MAX_MODEM_RESET_ASSERT_TIME_MS            500

//Delay in the OK response after AT+URTC is implemented
#define UART_POST_URTC_DELAY_MS                   2000

#define AUTORUN_ASSERT_LOW                        0x000
#define AUTORUN_ASSERT_HIGH                       0x100

#define EXTRA_FLAGS_DONTRELOCATE_AUTORUN          (0x0001)
#define EXTRA_FLAGS_ENABLE_HL_ASYNCRESP           (0x0002)
#define EXTRA_FLAGS_ENABLE_AUXRX_ASYNCRESP        (0x0004)

#define DRIVER_UART_IOCTLID_PARTIALLY_CLOSE       (0x1000)
#define DRIVER_UART_IOCTLID_REOPEN                (0x1001)


#define TEMPERATURE_CHECK_TIMER_MUILTIPLYER       60000  //ATS register is in minutes, this converts minutes to ms for the timer

//******************************************************************************
// Global Variable Declarations
//******************************************************************************

//Result code variable (used for checking if a function completed successfully or not)
dim rc

//Don't care value
dim tmpVar
dim tmpVar$
dim tmpDta$
dim parseTmp$

//Contains current state, see STATE_XXX
dim curState : curState = STATE_INIT
//Contains the state as we will need it later before entering a non-idle state
dim oldIdleState

//UART send/receive buffer (for application command mode)
dim urtTxCache$   : urtTxCache$ = ""
dim urtTxCacheLen : urtTxCacheLen = 0
dim urtRxBuf$     : urtRxBuf$ = ""
dim urtRxRelay$   : urtRxRelay$ = ""
dim urtBaud, urtFlow, urtTxBufLen, urtRxBufLen
dim urtOption$     //Contains the UART options for UartOpen()

dim urtTxCacheHL$   : urtTxCacheHL$ = ""
dim urtTxCacheLenHL : urtTxCacheLenHL = 0

//AUX send/receive buffer (for application command mode)
dim auxRxPatch$   : auxRxPatch$ = ""
dim auxTxCache$   : auxTxCache$ = ""
dim auxTxCacheLen : auxTxCacheLen = 0
dim auxBaud, auxFlow , auxTxBufLen, auxRxBufLen
dim auxOption$     //Contains the aux options for AuxOpen()

//Terminator for commands in command mode
dim cmdTerm$ : cmdTerm$ = "\r"

//Terminator for responses
dim rspTerm$ : rspTerm$ = "\r\n"
//Start sequence for responses
dim rspStart$ : rspStart$ = "\r\n"

//Terminator for debug messages
#cmpif 0x00000003 :  dim dbgStart$ : dbgStart$ = "\n## "
#cmpif 0x00000003 :  dim dbgTerm$  : dbgTerm$  = "\r\n"

//OK or ERROR response strings
dim ok$  : ok$  = AT_RESPONSE_OK
dim err$ : err$ = AT_RESPONSE_ERROR
//If the following is zero then the AT parser is suspended
dim atParse : atParse = 1

//This array is updated by ExtractXxxxx() functions
dim sArg$[MAX_ARGS_IN_ATCMD]
//This array is updated if an integer needs to be extracted from sArg$
dim nArg[MAX_ARGS_IN_ATCMD]

//Cache of SReg 100
dim startflags
dim extraFlags : extraFlags = 0

//Holds the timeout value that will disconnect a device that connects but doesn't
//encrypt the connection within the time (if the encryption flag is enabled)
dim encDisconTime   //if 0 then encryption via S102 is not requested

//This is the service UUID that was submitted to BleVspOpen
dim handleVspServiceUuid : handleVspServiceUuid = 0

//This is the service UUID that will be advertised in VSP mode
dim handleLteServiceUuid : handleLteServiceUuid = 0

//When scanning using AT+BLS, this is the pattern to search for in each advert report
dim scnPattern$
//This contains the length of the pattern$ string
dim scnPatternLen
//When scanning using AT+BLS, this is the minimum RSSI to allow
dim scnRssi

//These variables are used in the adv_report handler and are defined as globals
//to improve speed
dim periphAddr$, advData$, nDiscarded, nRssi, nme$

//This is the most recent i/o capability submitted to the stack
dim pairIoCapCache

//The following is non-zero if BleVspOpen() was successful and it implies that the
//vsp service has been added to the GATT table
dim vspAdded

//These are advert and scan reports that will be submitted when not in VSP mode
//and advertising
dim idleAdvRpt$, idleScnRpt$, idleAdvType, idleAdvIntvlMs

//These are the cache for the Scan related parameters
dim scanIntervalMs, scanWindowMs, scanType

//This is the pin to use to control low power UART operation mode.
dim lowPowerModePin

//Total number of connections active
dim connCount

//This is nonzero if GATT client is open
dim fGattClient : fGattClient = 0

// UUID handles.
dim uuidHandles[MAX_UUID_HANDLES]

//Metadata handles
dim metaHandles[MAX_METADATA_HANDLES + 1]

// Connection handles. Index 0 is used for Vsp Connection (as they are mutually exclusive)
dim connHandles[MAX_CONNECTIONS + 1]

//Char Handles that we manage - only index is sent to host
dim charHandles[MAX_CHARACTERISTICS + 1]  //index 0 is never used
dim numOfChars : numOfChars = 0

//Scan advert report display format
// 0 : default (abbreviated)
// 1 : full in hex format
dim scnFmt

//Outgoing VSP char/desc query array and array element definition is as per the
//#defines that follow
#define VSP_ATTR_INDEX_RX            0
#define VSP_ATTR_INDEX_TX            1
#define VSP_ATTR_INDEX_MDMIN         2
#define VSP_ATTR_INDEX_MDMOUT        3
#define VSP_ATTR_INDEX_TX_CCCD       4
#define VSP_ATTR_INDEX_MDMOUT_CCCD   5
#define VSP_ATTR_MAX_INDEXES         6
dim vspSvcUuid, hVspCccdUuids[VSP_ATTR_MAX_INDEXES], hVspAttr[VSP_ATTR_MAX_INDEXES]  //NArg[] i used to store CharUuid Handles

// this is the array index into hVspCccdUuids & hVspAttr when querying for attribute handles
dim vspFindIndex

//If a cccd write results in an error then this contains the status code
dim vspDisconSts
//If this is 1 then we are waiting for an ack from the VSP peer
dim vspAllowTx
//If this is 1 then we are waiting for an ack from the VSP peer
dim vspAllowRx
//This is the maximum attribute length for VSP
dim vspAttrMaxLen
//This is the maximum data chunk length based on negotiated ATT_MTU
dim vspChunkLen
//Following will be non-zero if the VSP connection is outgoing
dim vspIsOutGoing
//Following is minimum number of devices in trusted to start VSP adverts
dim vspMinTrusted

//This is the advert report prefix
dim advPrefix$

//Gatt Server use - current service handle being defined, non-0 if in the middle of
//entering a service
dim svcHandle : svcHandle = 0

//Gatt Server use - current characteristic handle being defined, non-0 if in the middle of
//entering a characteristic
dim chrInProg : chrInProg = 0

//Made this a global variables for various handlers & functions to use so that
//code size if reduced
dim charIdx

//This is used to improve the datapump when sending data out to the slave in VSP mode
//It is used to start a timer so that BleGattcWriteCmd() can be called again.
dim vspPumpToutMs

//Following used to help debug Vsp MODEM change activity
#cmpif 0x00000040 : dim vtxcnt : vtxcnt = 0
#cmpif 0x00000040 : dim vrxcnt : vrxcnt = 0

//NFC related
#cmpif 0x00200000 : dim nfcHandle       //returned by NfcOpoen
#cmpif 0x00200000 : dim ndefHandle      //returned by NfcNdefMsgNew
#cmpif 0x00200000 : dim nfcSenseCnt     //ATI50
#cmpif 0x00200000 : dim nfcReadCnt      //ATI51

dim fLowPwrUrtEnable : fLowPwrUrtEnable = 0   //Assume disabled
dim uartIdleToutMs

//Uart/Aux Multiplexer related variables
dim muxState      //See MUX_STATE_XXX #defines
dim muxSubState
dim muxToHL       //Will be 0 for 840 and 1 for HL
dim muxMode       //Multiplexer mode cached from S Reg 120
dim muxSio        //The sio pin number used to control and manage multiplexor
dim muxEscCount   //Escape character count
dim muxEscDelay   //Escape sequence delay
dim muxEsc$       //Specifies the escape string character
#cmpif 0x00800000 : dim muxBackSpc$   //Contains MUX_ESCAPE_MAXCOUNT backspace characters
dim muxCrPos      //Position of <cr> in input string
dim muxAuxRx$     //cache for data arriving from aux port
dim muxAuxRxLen   //data in muxAuxRx$
dim muxCr$ : muxCr$ = "\r"
dim muxLf$ : muxLf$ = "\n"
dim muxMatch$     //Used for caching the response
dim muxMatchLen   //temporary variable used to store the length of muxmatch$
dim muxFound      //will be true if muxMatch$ contains a transaction end string
dim muxRspEnd$[MUX_MAX_REP_END_STRINGS]

dim nSioRts, nSioTx      //On Aux Port
dim cmdPrefix$        //valid 2-character command prefixes
dim nPrefix

dim nUartDtr      //State of the SIO_LTE_UART1_DTR output pin
dim nPwrOnN       //state of the SIO_LTE_PWR_ON output pin
dim nWakeup       //state of the LTE_WAKE_UP output pin
dim nFastShutDnN  //state of the SIO_LTE_SHUTDOWN output pin
dim nResetN       //state of the SIO_LTE_RESET output pin
dim hlUartCts     //State of the UART1_CTS line from the HL78

dim nTxOnCnt      //Count of TX_ON lo-hi transitions since last time AT+CSTS command
dim nCurTXON

dim nVGpioCnt     //Count of VGPIO transitions since last time AT+CSTS command
dim nCurVGPIO

dim nGpio2Cnt     //Count of GPIO2 transitions since last time AT+CSTS command
dim nCurGPIO2

dim nGpio6Cnt     //Count of GPIO6 transitions since last time AT+CSTS command
dim nCurGPIO6

dim nUart1DsrCnt  //Count of UART1_DSR transitions since last time AT+CSTS command
dim nCurUART1DSR

dim hl78Sleeping  //Is non-zero is HL78 is sleeping
dim nHlState      //see #defines HLSTATE_xxxx

dim vg$[2]        //Cache for async response for VGPIO changes
dim g2$[2]        //Cache for async response for GPIO2 changes
dim g6$[2]        //Cache for async response for GPIO6 changes
dim ds$[2]        //Cache for async response for UART1_DSR changes
dim hltx$         //Cache for async response for when HL78 has sent data and mux to 840
dim fHlAsycSend   //Will be non-zero if VG/G2/G6/DS async responses are to be sent (Sreg 210)
dim fHlAuxRx      //Will be non-zero if AX async responses are to be sent (Sreg 210)

dim External32Mhz //Will be 1 if external 32MHz crystal is used, otherwise will be 0

//******************************************************************************
// Initialise Global Variable
//******************************************************************************

#cmpif 0x00200000 : nfcHandle  = INVALID_NFC_HANDLE
#cmpif 0x00200000 : ndefHandle = INVALID_NDEF_HANDLE
#cmpif 0x00200000 : nfcSenseCnt = 0
#cmpif 0x00200000 : nfcReadCnt  = 0

muxEsc$ = "!"   //This MUST be only 1 character long

//Initialise the AT response transaction strings of which there are MUX_MAX_REP_END_STRINGS
muxRspEnd$[0] = "OK\r"
muxRspEnd$[1] = "ERROR\r"
muxRspEnd$[2] = "+CME ERROR:"
//WANRING: if more elements are added to muxRspEnd$ then update MUX_MAX_REP_END_STRINGS accordingly

//These are all valid and potential 2-character command prefixes. the 4 AT variants
// MUST MUST have IDs 00 to 03, otherwise optimised code in ParseAtCommand() will break
cmdPrefix$ = "\00\02at\01\02aT\02\02At\03\02AT\04\02bt\05\02bT\06\02Bt\07\02BT"

//For now, allow 840 to sleep regardless of the state of the HL
hl78Sleeping = 1
nHlState = 0

//32MHz crystal is off at startup
External32Mhz = 0

//******************************************************************************
// Function and Subroutine definitions
//******************************************************************************

#include "$LIB$.debug.code.sb"

//------------------------------------------------------------------------------
// Change state
//------------------------------------------------------------------------------
sub NewState( nState )
  if nState != curState then
    #cmpif 0x00000004 : sprint #dbgmsg$, "NewState = "; nState
    #cmpif 0x00000004 : DbgMsg(dbgmsg$)
    curstate = nState
  endif
endsub

//------------------------------------------------------------------------------
// Save state info
//------------------------------------------------------------------------------
sub SaveState( byref prState )
  prState = curstate
endsub

//------------------------------------------------------------------------------
// Change Mux state
//------------------------------------------------------------------------------
sub NewMuxState( nState )
  #cmpif 0x00000020 : if nState != muxState then
  #cmpif 0x00000020 :   sprint #dbgmsg$, "MuxState = "; nState
  #cmpif 0x00000020 :   DbgMsg(dbgmsg$)
                        muxState = nState
  #cmpif 0x00000020 : endif
endsub

//------------------------------------------------------------------------------
// Change Mux sub state
//------------------------------------------------------------------------------
sub NewMuxSubState( nState )
  #cmpif 0x00000020 : if nState != muxSubState then
  #cmpif 0x00000020 :   sprint #dbgmsg$, "MuxSubState = "; nState ;"---\n"
  #cmpif 0x00000020 :   DbgMsg(dbgmsg$)
                        muxSubState = nState
  #cmpif 0x00000020 : endif
endsub

//------------------------------------------------------------------------------
// spins in a loop for the time specified - use sparingly
//------------------------------------------------------------------------------
sub SpinDelay(nDelayMs)
  dim strt, elapse
  strt = GetTickCount()
  while GetTickSince(strt)<nDelayMs
  endwhile
endsub

//------------------------------------------------------------------------------
// Update the HL78 VGPIO/GPIO2/GPIO6/UART1_DSR cache response strings
//------------------------------------------------------------------------------
sub UpdateHlRespCaches()
  vg$[0] = rspStart$+"VG:0"+rspTerm$
  vg$[1] = rspStart$+"VG:1"+rspTerm$

  g2$[0] = rspStart$+"G2:0"+rspTerm$
  g2$[1] = rspStart$+"G2:1"+rspTerm$

  g6$[0] = rspStart$+"G6:0"+rspTerm$
  g6$[1] = rspStart$+"G6:1"+rspTerm$

  ds$[0] = rspStart$+"DS:0"+rspTerm$
  ds$[1] = rspStart$+"DS:1"+rspTerm$

  hltx$ = rspStart$+"AX:"+rspTerm$
endsub

//Invoke it immediately
UpdateHlRespCaches()

//------------------------------------------------------------------------------
// This handler is called when Aux Tx buffer is empty and we want to do nothing
//------------------------------------------------------------------------------
function HndlrAuxTxEmptyNoAct() as integer
endfunc 1

//------------------------------------------------------------------------------
// This handler is called when data has arrived at the aux serial port and we
// do not want to touch it when in Mode 2
//------------------------------------------------------------------------------
function HndlrAuxNoAction2() as integer
endfunc 1

//------------------------------------------------------------------------------
// These are called when DisableUartAuxEvents() is called
//------------------------------------------------------------------------------
function HndlrAuxDisable() as integer
endfunc 1

//------------------------------------------------------------------------------
// Disble Uart and Aux Rx and txempty handlers
//------------------------------------------------------------------------------
sub DisableUartAuxEvents()
  OnEvent EVUARTRX       call HndlrAuxDisable
  OnEvent EVUARTTXEMPTY  call HndlrAuxDisable
  OnEvent EVAUXRX        call HndlrAuxDisable
  OnEvent EVAUXTXEMPTY   call HndlrAuxDisable
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub  GetFirmwareVersion(tmpVar$)
  dim val, p, mj, mn, b

  val = sysinfo(3)
  b = (val    ) & b'111111
  mn = (val>> 6) & b'111111111111
  mj = (val>>18) & b'111111
  p = (val>>24)

  sprint #tmpVar$, p;".";mj;".";mn;".";b
endsub

//------------------------------------------------------------------------------
// Function that will convert a string to lowercase - insitu
//------------------------------------------------------------------------------
sub StrToLower$(byref Text$)
  //Takes a string and replaces uppercase letters with lowercase letters
  dim i, chr
  i = strlen(Text$) - 1
  while (i >= 0)
    chr = StrGetChr(Text$, i)
    if (chr >= 65 && chr <= 90) then
      rc = StrSetChr(Text$, chr+32, i)
    endif
    i = i - 1
  endwhile
endsub

//------------------------------------------------------------------------------
// Returns the single letter AT command from the string or 0(RSP_OK) if the
// string is empty or just whitespace
//------------------------------------------------------------------------------
function GetAtCmdLetter(byref cmdStr$) as integer
  dim drop : drop = 0
  dim retVal

  while 1
    retVal = StrGetChr(cmdStr$, drop)
    if retVal<0 then
      StrShiftLeft(cmdStr$, drop)
      exitfunc RSP_OK
    elseif retVal>CHR_ASCII_SPACE then
      drop = drop + 1
      StrShiftLeft(cmdStr$, drop)
      exitfunc retVal
    endif
    //This is a whitespace
    drop = drop + 1
  endwhile
endfunc RSP_OK

//------------------------------------------------------------------------------
// Strip "" from str$ if they exist
//------------------------------------------------------------------------------
sub TrimQuotes(str$)
  dim len
  if strgetchr(str$, 0) == 0x22 then  //Check for beginning "
    len = strlen(str$)
    if len > 2 then
      if strgetchr(str$, (len - 1)) == 0x22 then //Check for ending "
        str$ = mid$(str$, 1, (len-2))
      endif
    elseif len == 2 then
      str$ = ""
    endif
  endif
endsub

//------------------------------------------------------------------------------
// Checks if the string is quoted
//------------------------------------------------------------------------------
function IsQuoted(str$)
  dim len
  if strgetchr(str$, 0) == 0x22 then  //Check for beginning "
    len = strlen(str$) - 1
    if len >= 1 then
      if strgetchr(str$, len) == 0x22 then //Check for ending "
        exitfunc 1
      endif
    endif
  endif
endfunc 0

//------------------------------------------------------------------------------
// Returns 0 if the value is outside min and max
//------------------------------------------------------------------------------
function InRange(newVal, minVal, maxVal) as integer
  if newVal<minVal then
    exitfunc 0
  elseif newVal>maxVal then
    exitfunc 0
  endif
endfunc 1

//------------------------------------------------------------------------------
// If the config value was different and got updated successfully, then the
// variable nUpdated is incremented
//------------------------------------------------------------------------------
sub SetConfigKey(keyId, newVal, byref nUpdated)
  dim curVal
  rc = NvCfgKeyGet(keyId, curVal)
  if rc == 0 then
    if newVal != curVal then
      rc = NvCfgKeySet(keyId, newVal)
      if rc == 0 then
        nUpdated = nUpdated + 1
      endif
    endif
  #cmpif 0x00000004 : else
  #cmpif 0x00000004 :   DbgMsgVal ("CFG KEY Set Fail ", keyId)
  endif
endsub

//******************************************************************************
//******************************************************************************
//******************************************************************************
// Initialisation values for sregister caches ...
//
// These values are created by running the application "sreg.defaults.creation.sb"
// and then copy/pasting its output here - verbatim.
//
// This technique is used to reduce the size of the .uwc file of the main sb file
//******************************************************************************
//******************************************************************************
//******************************************************************************
#include "$LIB$.SRegInterface.sb"
//******************************************************************************
//******************************************************************************
//******************************************************************************

//------------------------------------------------------------------------------
// Will return 1 if muxMatch$ has matches any one of the strings in the array
// of responses.
// This will be quicker than the above flavor but less efficient in code space
//------------------------------------------------------------------------------
function MuxFindMatch()
  if     StrPos(muxMatch$, muxRspEnd$[0], 0) == 0 then
    //Found at position 0
    //#cmpif 0x00000004 :  DbgMsgVal$("Match ", muxRspEnd$[0])
    exitfunc 1
  elseif StrPos(muxMatch$, muxRspEnd$[1], 0) == 0 then
    //Found at position 0
    //#cmpif 0x00000004 :  DbgMsgVal$("Match ", muxRspEnd$[1])
    exitfunc 1
  elseif StrPos(muxMatch$, muxRspEnd$[2], 0) == 0 then
    //Found at position 0
    //#cmpif 0x00000004 :  DbgMsgVal$("Match ", muxRspEnd$[2])
    exitfunc 1
  endif
endfunc 0

//------------------------------------------------------------------------------
// Get node index number from connection handle. If not found 0 will be returned
// otherwise a number between 1 and MAX_CONNECTIONS
//------------------------------------------------------------------------------
function GetIdxFromHConn(hConn as integer) as integer
  dim i
  //Search for the address through the node cache which will also unconnected
  for i = 1 to MAX_CONNECTIONS  //start from index 1 because 0 is dedicated for VspConnection
    if connHandles[i] == hConn then
      exitfunc i
    endif
  next
endfunc 0

//------------------------------------------------------------------------------
// Get free node index number for connection handle. If not found 0 will be returned
// otherwise a number between 1 and MAX_CONNECTIONS
//------------------------------------------------------------------------------
function GetFreeIdx() as integer
  dim i
  //Search for an empty handle
  for i = 1 to MAX_CONNECTIONS
    if connHandles[i] == INVALID_CONN_HANDLE then
      exitfunc i
    endif
  next
endfunc 0

//------------------------------------------------------------------------------
// Save a characteristic handle to the managed array so that we can report an
// index number to the host.
//------------------------------------------------------------------------------
function AddCharHandle(charH, byref nIdx) as integer
  if numOfChars<MAX_CHARACTERISTICS then
    numOfChars = numOfChars + 1
    nIdx = numOfChars
    charHandles[nIdx] = charH
    exitfunc RSP_OK
  endif
endfunc RSP_TOO_MANY_CHARACTERISTICS

//------------------------------------------------------------------------------
// Get node index number from characteristic handle. If not found 0 will be returned
// otherwise a number between 1 and MAX_CHARACTERISTICS
//------------------------------------------------------------------------------
function GetIdxFromHChar(hChar as integer) as integer
  dim i
  //Search for the address through the node cache which will also unconnected
  for i = 1 to MAX_CHARACTERISTICS  //start from index 1 because 0 is dedicated for VspConnection
    if charHandles[i] == hChar then
      exitfunc i
    endif
  next
endfunc 0

//------------------------------------------------------------------------------
// The rest of the str$ should be up to MAX_ARGS_IN_ATCMD arguments separated by ', '
// returns RSP_OK if ok and 'args' is updated with number of args and the global
// string array sArg$[] contains the arguments (but not the ', ')
// If any arguments have "" delimiters they are removed
//------------------------------------------------------------------------------
function ExtractArgsCSV(str$, byref args, minargs, maxargs)
  dim tlen, commaExp, chr

  #cmpif 0x00000003 : AssertBound(minargs, 0, MAX_ARGS_IN_ATCMD, 2870)
  #cmpif 0x00000003 : AssertBound(maxargs, minargs, MAX_ARGS_IN_ATCMD, 2880)

  args = 0
  commaExp = 0  //1 for expected

  //Clear up to maxargs
  for chr = 0 to maxargs
    sArg$[chr] = ""
  next

  //Special case check if maxargs is 0 and the line is not empty
  tlen = ExtractStrToken(str$, tmpVar$)
  if tlen>0 then
    //First argument will not have a preceding comma, unless it is missing
    if strcmp(tmpVar$, ", ") == 0 then
      //Unexpected comma so empty string
      sArg$[0] = ""
    else
      //Remove delimiting "" quotes
      TrimQuotes(tmpVar$)
      //Save it in the args array
      sArg$[0] = tmpVar$
      //Now extract another token and that could be a comma
      tlen = ExtractStrToken(str$, tmpVar$)
    endif
    args = 1
    //Check if too many args already encountered
    if args>maxargs then
      exitfunc RSP_ERROR_TOOMANYARGS
    endif
  endif

  //At this point tmpVar$ has to be comma or empty

  //Now parse the string further
  while tlen>0
    //Check if too many args already encountered
    if args>= maxargs then
      exitfunc RSP_ERROR_TOOMANYARGS
    endif

    //This has to be a comma
    if strcmp(tmpVar$, ", ") == 0 then
      //Increment the count
      sArg$[args] = ""
    else
      exitfunc RSP_ERROR_SYNTAX_ERROR
    endif

    //Now extract another token and that should be an arg, a comma, or empty
    tlen = ExtractStrToken(str$, tmpVar$)
    if tlen>0 then
      if strcmp(tmpVar$, ", ") == 0 then
        //Got an empty parameter so do nothing here, args count incremented later
      elseif strcmp(tmpVar$, "-") == 0 then
        //Looks like there could be a negative number
        if strlen(str$) > 0 then
          chr = StrGetChr(str$, 0)
          if (chr>= 0x30)&&(chr<= 0x39) then
            //It is a decimal digit
            tlen = ExtractStrToken(str$, tmpVar$)
            //Save it in the args array
            sArg$[args] = "-" + tmpVar$
            //Now extract another token and that should be a comma or empty
            tlen = ExtractStrToken(str$, tmpVar$)
          endif
        else
          //There are no more characters
          sArg$[args] = tmpVar$
          tlen = 0
        endif
      else
        //Remove delimiting "" quotes
        TrimQuotes(tmpVar$)
        //Save it in the args array
        sArg$[args] = tmpVar$
        //Now extract another token and that should be a comma or empty
        tlen = ExtractStrToken(str$, tmpVar$)
      endif
    endif
    args = args + 1
  endwhile

  //#cmpif 0x00000004 : dim i
  //#cmpif 0x00000004 : DbgMsgVal ("args = ", args)
  //#cmpif 0x00000004 : for i = 0 to (MAX_ARGS_IN_ATCMD - 1)
  //#cmpif 0x00000004 :   print dbgStart$;"sArg$[";i;"] = ";sArg$[i]
  //#cmpif 0x00000004 : next

  //Check if too few args parsed
  if args < minargs then
    exitfunc RSP_ERROR_TOOFEWARGS
  endif
endfunc RSP_OK

////------------------------------------------------------------------------------
//// The rest of the str$ should not be up to MAX_ARGS_IN_ATCMD arguments which are
//// whitespace delimited as opposed to ', ' delimited as in ExtractArgsCSV()
////
//// As it is not currently called, but could be in the future, it is commented out
////------------------------------------------------------------------------------
//function ExtractArgsStr(str$, byref args, minargs, maxargs)
//  dim tlen
//
//  #cmpif 0x00000003 : AssertBound(minargs, 0, MAX_ARGS_IN_ATCMD, 3600)
//  #cmpif 0x00000003 : AssertBound(maxargs, minargs, MAX_ARGS_IN_ATCMD, 3610)
//
//  args = 0
//
//  //Extract first token
//  tlen = ExtractStrToken(str$, tmpVar$)
//  //then loop until max done
//  while tlen>0
//    //check if too many args already encountered
//    if args>= maxargs then
//      exitfunc RSP_ERROR_TOOMANYARGS
//    endif
//
//    //remove delimiting "" quotes
//    TrimQuotes(tmpVar$)
//    //save it in the args array
//    sArg$[args] = tmpVar$
//    #cmpif 0x00008000 : print "\narg = ";tmpVar$
//    //increment
//    args = args + 1
//    //now extract another token and that should be a comma or empty
//    tlen = ExtractStrToken(str$, tmpVar$)
//
//  endwhile
//
//  //check if too few args parsed
//  if args < minargs then
//    exitfunc RSP_ERROR_TOOFEWARGS
//  endif
//endfunc RSP_OK

//------------------------------------------------------------------------------
// Attempt to convert sArg$[ndx] into an integer and saves in nArg[ndx] and
// will also check that the values is >= mn and <= mx
//------------------------------------------------------------------------------
function SArgConvertToInt( ndx, defval, mn, mx)
  dim val

  #cmpif 0x00000003 : AssertBound(ndx, 0, (MAX_ARGS_IN_ATCMD - 1), 5720)

  if strlen(sArg$[ndx]) == 0 then
    //Not specified so set to default
    val = defval
  else
    //A threshold has been specified so attempt to convert to an integer
    if ExtractIntToken(sArg$[ndx], val) == 0 then
      exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
  endif
  if (val<mn)||(val>mx) then
    exitfunc RSP_ERROR_VALUE_NOT_VALID
  endif
  nArg[ndx] = val
endfunc RSP_OK

//------------------------------------------------------------------------------
// Enable the xtal based HF clock
//------------------------------------------------------------------------------
sub SetXtalHfClock(fOn)
  dim nSrc
  if fOn then
    nSrc = 1 //Based on xtal
  else
    nSrc = 0 //Based on rc oscillator
  endif
  BleConfigHfClock(nSrc) //Based on rc oscillator
endsub

//------------------------------------------------------------------------------
// Close the UART if rx/Tx buffers are empty, called when the lowpower input
// pin is low and also when the low power idle timer expires
//------------------------------------------------------------------------------
sub UartAuxCloseCond()
  if fLowPwrUrtEnable then
    #cmpif 0x02000000 :  if hl78Sleeping then
      //Close only if the cmdpin is deasserted
      if GpioRead(lowPowerModePin) == 0 then
        //Host does not care if we close the UART

        if UartInfo(6) == 0 then
          if AuxInfo(6) == 0 then
            //Both Uart and Aux rx/Tx buffers are empty
            AuxClose()
            //Rc = gpiosetfunc(nSioRts, SIOTYPE_DOUT, OUTPUT_INIT_HI)  //RTS set high to de-assert

            UartClose()
            rc = gpiosetfunc(UART_SIONUM_RTS, SIOTYPE_DOUT, OUTPUT_INIT_HI)  //RTS set high to de-assert

            //Ok to switch off the xtal
            SetXtalHfClock(FALSE)

            exitsub //So that the timer is not restarted
          endif
          //Timer will be restarted below
          #cmpif 0x00000004 :  DbgMsgVal("AuxInfo(6) = ", AuxInfo(6))
        endif
        //Timer will be restarted below
        #cmpif 0x00000004 :  DbgMsgVal("AuxInfo(6) = ", UartInfo(6))
      endif

      //Start the UART inactivity timer as the host is allowing us to
      TimerStart(TMRNUM_LOWPWR_UARTandAUX, uartIdleToutMs, 0)
        #cmpif 0x00000004 :  DbgMsg("Uart Tmr STARTv")
    #cmpif 0x02000000 :endif
  endif
endsub

//------------------------------------------------------------------------------
// Open Main Uart
//------------------------------------------------------------------------------
sub OpenMainUart()
  //Open the UART with comms parms from S Registers
  rc = UartOpen(urtBaud, urtTxBufLen, urtRxBufLen, urtOption$)
  #cmpif 0x00000003 : AssertRC(11170)

  if rc == 0 then
    //Switch on the xtal
    SetXtalHfClock(TRUE)
  endif

  //If flow control is not enabled then config RTS and CTS appropriately
  if urtFlow == 0 then
    rc = GpioSetFunc(SIO_UART_RTS, SIOTYPE_DOUT, OUTPUT_INIT_LOW)  //Assert RTS
    rc = GpioSetFunc(SIO_UART_CTS, SIOTYPE_DIN, INPUT_PULL_DOWN)   //Assert CTS via pulldown
  endif

  if fLowPwrUrtEnable then
    if GpioRead(lowPowerModePin) == 0 then
      //Start the UART inactivity timer if we are in low power operation
      TimerStart(TMRNUM_LOWPWR_UARTandAUX, uartIdleToutMs, 0)
      #cmpif 0x00000104 :  DbgMsg("Uart Tmr STARTi")
    endif
  endif
endsub

//------------------------------------------------------------------------------
// Reopen the UART and if it was closed when in low power mode
// unconditionally restarts the idle timer
//------------------------------------------------------------------------------
sub UartReOpen()
  if fLowPwrUrtEnable then
    if UartInfo(0) == 0 then
      //Uart is actually closed so open it
      OpenMainUart()
    endif
  endif
endsub

//------------------------------------------------------------------------------
// Routine for sending buffered data for the UART from the 840
// it is ok if urtTxCache$ is empty
//------------------------------------------------------------------------------
sub UartSendFrom840()
  if muxToHL == 0 then
    urtTxCacheLen = StrLen(urtTxCache$)
    if (urtTxCacheLen > 0) then
      //Send UART data
      UartReOpen()
      rc = UARTWrite(urtTxCache$)  //Returns the number of bytes actually written
      StrShiftLeft(urtTxCache$, rc)
      urtTxCacheLen = urtTxCacheLen - rc
    endif
  endif
endsub

//------------------------------------------------------------------------------
// Routine for sending buffered data for the UART from the 840
//------------------------------------------------------------------------------
sub UartSendFrom840Ex(byref newData$)
  //~~~~~~~~
  //WARNING: if you decide to remove the check on muxToHle then please ensure
  //         that you make it happen in SendAsyncHl78Status()
  //~~~~~~~~
  if muxToHL == 0 then
    if urtTxCacheLen == 0 then
      //Nothing in UART Tx cache
      UartReOpen()
      rc = UARTWrite(newData$)  //Returns the number of bytes actually written
      urtTxCacheLen = strlen(newData$) - rc
      if urtTxCacheLen then
        //All data not sent
        urtTxCache$ = mid$(newData$, rc, urtTxCacheLen)
      endif
    else
      urtTxCache$ = urtTxCache$+newData$
      UartSendFrom840()
    endif
    //On exit urtTxCacheLen!= 0 if aux Tx buffer is full
  endif
endsub

//------------------------------------------------------------------------------
// Routine for sending buffered data for the UART from the HL
//------------------------------------------------------------------------------
sub UartSendFromHL()
  if muxToHL then
    urtTxCacheLenHL = StrLen(urtTxCacheHL$)
    if (urtTxCacheLenHL > 0) then
      //Send UART data
      UartReOpen()
      rc = UARTWrite(urtTxCacheHL$)  //Returns the number of bytes actually written
      StrShiftLeft(urtTxCacheHL$, rc)
      urtTxCacheLenHL = urtTxCacheLenHL - rc
    endif
  endif
endsub

//------------------------------------------------------------------------------
// This handler is called when data has arrived at the aux serial port and we
// do not want to touch it
//------------------------------------------------------------------------------
function HndlrAuxRxNoAction() as integer
  //No need to check if muxToHL == 0 because UartSendFrom840Ex() does it
  if fHlAuxRx then
    UartSendFrom840Ex(hltx$)  //Will check if muxToHL is 0
  endif
endfunc 1

//------------------------------------------------------------------------------
// Change HL78 state
//------------------------------------------------------------------------------
sub NewHlState( nState )
  if nState != nHlState then
  #cmpif 0x00000004 :   sprint #dbgmsg$, "CM State = "; nState>>4;", ";nState&0xF ;"\n"
  #cmpif 0x00000004 :   DbgMsg(dbgmsg$)
    nHlState = nState
    //Update output to indicate HL ready to accept AT commands
    if nHlState == HLSTATE_RUN then
      GpioWrite(SIO_HL78_READY, 0)
    else
      GpioWrite(SIO_HL78_READY, 1)
    endif
    sprint #tmpVar$, rspStart$;"CM:";nHlState>>4;rspTerm$
    UartSendFrom840Ex(tmpVar$)
  endif
endsub

//------------------------------------------------------------------------------
// Send HL78 status of VGPIO, GPIO2, GPIO6, UART1DSR in that order and
// separated by comma
//------------------------------------------------------------------------------
sub SendAsyncHl78Status(byref rsp$ as string)
  //No need to check if muxToHL == 0 because UartSendFrom840Ex() does it
  if fHlAsycSend then
    UartSendFrom840Ex(rsp$)  //Will check if muxToHL is 0
  endif
endsub


//------------------------------------------------------------------------------
// Reopen the aux and if it was closed
// unconditionally restarts the idle timer
//------------------------------------------------------------------------------
sub AuxReOpen()
  if fLowPwrUrtEnable then
    if AuxInfo(0) == 0 then
      //Aux was actually closed so open it
      rc = AuxOpen(auxBaud, auxTxBufLen, auxRxBufLen, auxOption$)
        #cmpif 0x00000103 :  AssertRC(12110)

      if rc == 0 then
        //Switch on the xtal
        SetXtalHfClock(TRUE)
      endif

      //If VGPIO is low then immediately partially close it
      if nCurVGPIO == 0 then
          #cmpif 0x00000104 :  DbgMsg("VGPIO low so close Aux hardware")
        rc = AuxIoctl(DRIVER_UART_IOCTLID_PARTIALLY_CLOSE, tmpVar, tmpVar)
          #cmpif 0x00000003 : AssertRC(13860)
      endif

    elseif GpioRead(lowPowerModePin) == 0 then
      //Start the UART inactivity timer
      TimerStart(TMRNUM_LOWPWR_UARTandAUX, uartIdleToutMs, 0)
        #cmpif 0x00000104 :  DbgMsg("Aux Tmr STARTr")
    endif
  endif
endsub

//------------------------------------------------------------------------------
// Routine for sending buffered data for the AUX
// on exit auxTxCacheLen will be non-0 if aux Tx buffer is full
//------------------------------------------------------------------------------
sub AuxSendData()
  auxTxCacheLen = StrLen(auxTxCache$)
  if (auxTxCacheLen > 0) then
    //Send AUX data
    AuxReOpen()
    rc = AuxWrite(auxTxCache$)  //Returns the number of bytes actually written
    StrShiftLeft(auxTxCache$, rc)
    auxTxCacheLen = auxTxCacheLen - rc
  endif
  //On exit auxTxCacheLen!= 0 if aux Tx buffer is full
endsub

//------------------------------------------------------------------------------
// Routine for sending buffered data for the AUX
// on exit auxTxCacheLen will be non-0 if aux Tx buffer is full
//------------------------------------------------------------------------------
sub AuxSendDataEx(byref newData$)
  if auxTxCacheLen == 0 then
    //Nothing in aux Tx cache
    AuxReOpen()
    rc = AuxWrite(newData$)  //Returns the number of bytes actually written
    auxTxCacheLen = strlen(newData$) - rc
    if auxTxCacheLen then
      //All data not sent
      auxTxCache$ = mid$(newData$, rc, auxTxCacheLen)
    endif
  else
    auxTxCache$ = auxTxCache$+newData$
    AuxSendData()
  endif
  //On exit auxTxCacheLen!= 0 if aux Tx buffer is full
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub AtParserResume()
  if atParse == 0 then
    //Suspend to resume transition
    atParse = 1
    // and send a message to tickle handlers if appropriate
    rc = SendMsgApp(MSGAPP_PROCESS_PARSER_RESUMED, NULL_CTX)
  endif
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub AppendRspEnd(rsp as integer, byref bufferStr$ )
  dim tmpStr$
  if rsp == 0 then
    tmpStr$ = ok$
  elseif rsp > 99 then
    sprint #tmpStr$, integer.h' rsp
    tmpStr$ = err$ + right$(tmpStr$, 4)
  elseif rsp > 0 then
    sprint #tmpStr$, "0";rsp
    tmpStr$ = err$ + right$(tmpStr$, 2)
  else
    atParse = 0
    exitsub
  endif
  bufferStr$ = bufferStr$ + rspStart$ + tmpStr$ + rspTerm$
  AtParserResume()
endsub

//------------------------------------------------------------------------------
// For valid values of 'rsp' see CONN_xxxx #defines
//------------------------------------------------------------------------------
sub GetConnInfoRsp(hConn, byref rsp$, byref intrvl )
  dim addr$, sprvto, slat

  rc = BleGetCurConnParms(hConn, intrvl, sprvto, slat)
  #cmpif 0x00000003 : AssertRC(12960)

  rc = BleGetAddrFromConnHandle(hConn, addr$)
  #cmpif 0x00000003 : AssertRC(12990)

  sprint #rsp$, StrHexize$(addr$);", ";intrvl;", ";sprvto;", ";slat
endsub

//------------------------------------------------------------------------------
// For valid values of 'rsp' see CONN_xxxx #defines
//------------------------------------------------------------------------------
sub AppendConnRspEnd(rsp as integer, byref bufferStr$ )
  dim tmpStr$, info$, intrvl
  if rsp == 0 then
    GetConnInfoRsp(connHandles[HCONN_VSP], info$, intrvl)
    sprint #tmpStr$, "CONNECT 0, ";info$
    //Set the data pump timer for when BleGattcWriteCmd fails due to lack of buffers
    vspPumpToutMs = (intrvl + 2500) / 1000
  elseif rsp > 0 then
    sprint #tmpStr$, "NOCARRIER ";rsp
  else
    atParse = 0
    exitsub
  endif
  bufferStr$ = bufferStr$ + rspStart$ + tmpStr$ + rspTerm$
  AtParserResume()
endsub

//------------------------------------------------------------------------------
// Cache idleAdvType with Sreg value
//------------------------------------------------------------------------------
sub CacheAdvertType()
  idleAdvType  = SRegGet(CfgId_IdleAdvertType)
  if idleAdvType == ADV_DIRECT_IND then
    //Idle mode adverts are not allowed to be ADV_DIRECT_IND
    idleAdvType = ADV_IND
  endif
endsub

//------------------------------------------------------------------------------
// On non VSP connection, this is used to send the confirming 'connect' message
//------------------------------------------------------------------------------
sub SendNonVspConnect(ndx as integer, byref bufferStr$ )
  dim tmpStr$, info$, intrvl

  GetConnInfoRsp(connHandles[ndx], info$, intrvl)
  sprint #tmpStr$, "connect ";ndx;", ";info$

  bufferStr$ = bufferStr$ + rspStart$ + tmpStr$ + rspTerm$
  AtParserResume()

  //Send out data waiting in buffer
  UartSendFrom840()
endsub

//------------------------------------------------------------------------------
// Used to send "RING " response on an incoming VSP connection
//------------------------------------------------------------------------------
sub SendRingRsp(hConn as integer, byref bufferStr$ )
  dim addr$, isTrusted, keyInfo, rollAge, rollCount
  rc = BleGetAddrFromConnHandle(hConn, addr$)
  #cmpif 0x00000003 : AssertRC(13570)

  isTrusted = BleBondingIsTrusted(addr$, BOND_TRUSTED_AS_CENTRAL, keyInfo, rollAge, rollCount)

  addr$ = StrHexize$(addr$)
  bufferStr$ = bufferStr$ + rspStart$ + "RING " + addr$

  if isTrusted then
    addr$ = ", T"
  else
    addr$ = ", U"
  endif

  bufferStr$ = bufferStr$ + addr$ + rspTerm$

  //Send out data waiting in buffer
  UartSendFrom840()
endsub

//------------------------------------------------------------------------------
// For valid values of 'rsp' see CONN_xxxx #defines
//------------------------------------------------------------------------------
sub SendNonVspDiscon(rsp as integer, ndx as integer, byref bufferStr$ )
  sprint #tmpVar$, "discon ";ndx;", ";rsp
  bufferStr$ = bufferStr$ + rspStart$ + tmpVar$ + rspTerm$

  AtParserResume()

  //Send out data waiting in buffer
  UartSendFrom840()
endsub

//------------------------------------------------------------------------------
// This is sent on non_VSP states when scanning times out
//------------------------------------------------------------------------------
sub SendScanEnd(byref bufferStr$ )
  bufferStr$ = bufferStr$ + rspStart$ + "scanend" + rspTerm$

  //Send out data waiting in buffer
  UartSendFrom840()
endsub

//------------------------------------------------------------------------------
// This is sent when a passcode needs to be displayed
//------------------------------------------------------------------------------
sub SendDispPassKey(npsky, byref bufferStr$ )
  dim tmp$

  sprint #tmp$, "000000";npsky

  bufferStr$ = bufferStr$ + rspStart$ + "showcode " + right$(tmp$, 6) + rspTerm$

  //Send out data waiting in buffer
  UartSendFrom840()
endsub

//------------------------------------------------------------------------------
// This is sent when an authkey is required and
// keytype = 1 for passcode (0 to 999999)
// keytype = 2 for 32 hex digit OOB key
//------------------------------------------------------------------------------
sub SendAuthKeyReq(keyType, byref bufferStr$ )
  dim tmp$
  select keyType
  case BLE_GAP_AUTH_KEY_TYPE_PASSKEY
    tmp$ = "passkey?"

  case BLE_GAP_AUTH_KEY_TYPE_OOB
    tmp$ = "oobkey?"

  case else
    tmp$ = "xxkey?"
  endselect
    bufferStr$ = bufferStr$ + rspStart$ + tmp$ + rspTerm$

  //Send out data waiting in buffer
  UartSendFrom840()
endsub

//------------------------------------------------------------------------------
// Send 'Encrypt' message
//------------------------------------------------------------------------------
sub SendEncryptRsp(ndx, sndMsg, byref bufferStr$ )
  dim msg$
  select sndMsg
  case 1
    msg$ = "ENCRYPT"

  case 2
    sprint #msg$, "encrypt ";ndx

  case else
  endselect
  if sndMsg>0 then
    bufferStr$ = bufferStr$ + rspStart$ + msg$ + rspTerm$
    //Send out data waiting in buffer
    UartSendFrom840()
  endif
endsub

//------------------------------------------------------------------------------
//  8-bit S-Registers are 100-199
// 16-bit S-Registers are 200-299
// 32-bit S-Registers are 300-399
//------------------------------------------------------------------------------
function ATSRegGetValue(regnum, byref rspBuf$)
  if (regnum >= SREGNUM_START_8BIT) && (regnum<(SREGNUM_START_8BIT+SREG_MAXREGISTERS_8)) then
    //This is 8-bit register access
    regnum = regnum-SREGNUM_START_8BIT
  elseif (regnum >= SREGNUM_START_16BIT) && (regnum<(SREGNUM_START_16BIT+SREG_MAXREGISTERS_16)) then
    //This is 16-bit register access
    regnum = regnum + 0x10000 - SREGNUM_START_16BIT
  elseif (regnum >= SREGNUM_START_32BIT) && (regnum<(SREGNUM_START_32BIT+SREG_MAXREGISTERS_32)) then
    //This is 32-bit register access
    regnum = regnum + 0x20000 - SREGNUM_START_32BIT
  else
    exitfunc RSP_ERROR_INVALID_S_REG
  endif

  dim regval$
  sprint #regval$, SRegGet(regnum)
  rspBuf$ = rspBuf$ + rspStart$ + regval$ + rspTerm$

endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegSetValue(regnum, regVal)
  if (regnum >= SREGNUM_START_8BIT) && (regnum<(SREGNUM_START_8BIT+SREG_MAXREGISTERS_8)) then
    //This is 8-bit register access
    regnum = regnum-SREGNUM_START_8BIT
  elseif (regnum >= SREGNUM_START_16BIT) && (regnum<(SREGNUM_START_16BIT+SREG_MAXREGISTERS_16)) then
    //This is 16-bit register access
    regnum = regnum + 0x10000 - SREGNUM_START_16BIT
  elseif (regnum >= SREGNUM_START_32BIT) && (regnum<(SREGNUM_START_32BIT+SREG_MAXREGISTERS_32)) then
    //This is 32-bit register access
    regnum = regnum + 0x20000 - SREGNUM_START_32BIT
  else
    exitfunc RSP_ERROR_INVALID_S_REG
  endif

  //Check if valid range
  dim mn, mx
  mn = SRegGetRange(regnum, mx)
  if (regVal<mn) || (regVal>mx) then
    exitfunc RSP_ERROR_VALUE_OUT_OF_RANGE
  endif

  SRegSet(regnum, regVal)
endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegGetRange(regnum, byref rspBuf$)
  if (regnum >= SREGNUM_START_8BIT) && (regnum<(SREGNUM_START_8BIT+SREG_MAXREGISTERS_8)) then
    //This is 8-bit register access
    regnum = regnum-SREGNUM_START_8BIT
  elseif (regnum >= SREGNUM_START_16BIT) && (regnum<(SREGNUM_START_16BIT+SREG_MAXREGISTERS_16)) then
    //This is 16-bit register access
    regnum = regnum + 0x10000 - SREGNUM_START_16BIT
  elseif (regnum >= SREGNUM_START_32BIT) && (regnum<(SREGNUM_START_32BIT+SREG_MAXREGISTERS_32)) then
    //This is 32-bit register access
    regnum = regnum + 0x20000 - SREGNUM_START_32BIT
  else
    exitfunc RSP_ERROR_INVALID_S_REG
  endif

  dim regval$, mn, mx
  mn = SRegGetRange(regnum, mx)
  sprint #regval$, mn;"..";mx
  rspBuf$ = rspBuf$ + rspStart$ + regval$ + rspTerm$
endfunc RSP_OK

//------------------------------------------------------------------------------
// String S-Registers start at 0
//------------------------------------------------------------------------------
function ATSRegGetValueStr(regnum, byref rspBuf$)
  if (regnum >= SREGNUM_START_STR) && (regnum<(SREGNUM_START_STR+SREG_MAXREGISTERS_STR)) then
    tmpVar$ = SRegGetStr$((regnum-SREGNUM_START_STR))
    rspBuf$ = rspBuf$ + rspStart$ + StrEscape$(tmpVar$) + rspTerm$
    exitfunc RSP_OK
  endif
endfunc RSP_ERROR_INVALID_S_REG

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegSetValueStr(regnum, regVal$)
  if (regnum >= SREGNUM_START_STR) && (regnum<(SREGNUM_START_STR+SREG_MAXREGISTERS_STR)) then
    //Check if valid range
    dim mn, mx, len

    regnum = regnum - SREGNUM_START_STR

    //Get the valid min/max for this register
    mn = SRegGetStrSizeRange(regnum, mx)
    //De-escape the string
    StrDeEscape(regVal$)  //ensure escaped characters are converted to single binary values

    //Check for valid length
    len = strlen(regVal$)
    if (len<mn) || (len>mx) then
      exitfunc RSP_ERROR_VALUE_OUT_OF_RANGE
    endif

    //Perform further checking
    select regnum
    case CfgIdStr_VspServiceUUID128
      //This must only contain hex characters
      tmpVar$ = strdehexize$(regVal$)
      if strlen(tmpVar$) != 16 then
        exitfunc RSP_ERROR_INVALID_HEXSTR
      endif

    case else
    endselect

    SRegSet$(regnum, regVal$)
    exitfunc RSP_OK

  endif
endfunc RSP_ERROR_INVALID_S_REG

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function ATSRegGetLenRangeStr(regnum, byref rspBuf$)
  if (regnum >= SREGNUM_START_STR) && (regnum<(SREGNUM_START_STR+SREG_MAXREGISTERS_STR)) then
    dim tmp$, mn, mx
    mn = SRegGetStrSizeRange((regnum-SREGNUM_START_STR), mx)
    sprint #tmp$, mn;", ";mx
    rspBuf$ = rspBuf$ + rspStart$ + tmp$ + rspTerm$
    exitfunc RSP_OK
  endif
endfunc RSP_ERROR_INVALID_S_REG

//------------------------------------------------------------------------------
// Change PHY per start-up flag
//------------------------------------------------------------------------------
function ChangePhy( connHandle )
  dim nPhyReq
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  nPhyReq = ((startflags>>5) & 0x00000003)
  select nPhyReq
    #cmpif 0x00100000 :   case 1  // Long Range 125 kbps
    #cmpif 0x00100000 :     nPhyReq = 4

  case 3  // 2MPHY
    nPhyReq = 2

  case else  // 1MPHY
    exitfunc 0

  endselect
  #cmpif 0x00000001 :  print dbgStart$;"nPhyReq = ";nPhyReq
endfunc BlePhySet(connHandle, nPhyReq, nPhyReq, 0)

//------------------------------------------------------------------------------
// If advertising then return non-zero
//------------------------------------------------------------------------------
function IsAdvertising()
  if (sysinfo(2016) & 0x1) then
    exitfunc 1
  endif
endfunc 0

//------------------------------------------------------------------------------
// If scanning then return non-zero
//------------------------------------------------------------------------------
function IsScanning()
  if (sysinfo(2016) & 0x8) then
    exitfunc 1
  endif
endfunc 0

//------------------------------------------------------------------------------
// If advertising in progress stop it
//------------------------------------------------------------------------------
sub AdvertsStop()
  #cmpif 0x00000004 : DbgMsg("Called AdvertsStop()")
  if IsAdvertising() then
    rc = BleAdvertStop()
    #cmpif 0x00000003 : AssertRC(16450)
    #cmpif 0x00000004 : DbgMsg("Adverts Stopped")
  endif
endsub

//------------------------------------------------------------------------------
// If scanning in progress stop it
//------------------------------------------------------------------------------
sub ScanningStop()
  #cmpif 0x00000004 : DbgMsg("Called ScanningStop()")
  if IsScanning() then
    rc = BleScanStop()
    #cmpif 0x00000003 : AssertRC(16570)
    #cmpif 0x00000004 : DbgMsg("Scanning Stopped")
  endif
endsub

//------------------------------------------------------------------------------
// Stop & restart scanning
//------------------------------------------------------------------------------
function ScanningStart(tout, filter$, rsi)
  ScanningStop()
  rc = BleScanStart( tout, 0)
  #cmpif 0x00000008 :   AssertRC(16680)

  //Set up the filtering parameters for the scan reporting
  if rc == 0 then
    scnPattern$   = filter$
    scnPatternLen = strlen(filter$)
    scnRssi       = rsi
  endif

  #cmpif 0x00000004 : if rc == 0 then
  #cmpif 0x00000004 :   DbgMsg(    "Scanning Started")
  #cmpif 0x00000004 :   DbgMsgVal( "  Scan Tout (sec) = ", tout)
  #cmpif 0x00000004 :   DbgMsgVal$("  Scan Pattern   = ", filter$)
  #cmpif 0x00000004 :   DbgMsgVal( "  Scan Rssi (dBm) = ", rsi)
  #cmpif 0x00000004 : else
  #cmpif 0x00000004 :   DbgMsg("Failed to start Scanning")
  #cmpif 0x00000004 : endif
endfunc rc

//------------------------------------------------------------------------------
// Load VSP service defaults into sArg$[] and nArg[] to set things up as follows
//   sArg$[0] =
//   nArg[1]  = TxBufLen
//   nArg[2]  = RxBufLen
//   nArg[3]  = VspServiceUuid
//   nArg[4]  = RxUUID
//   nArg[5]  = TxUUID
//   nArg[6]  = MdmInUUID
//   nArg[7]  = MdmOutUUID
//   nArg[8]  = EncryptionReq (bit 0 set to encrypt, 1 set for MITM)
//------------------------------------------------------------------------------
sub VspGetDefs()
  dim tmpStr$

  //Get Tx & Rx buffer sizes
  nArg[1] = SRegGet( CfgId_VspTxBufSize )
  nArg[2] = SRegGet( CfgId_VspRxBufSize)

  //If DLE is enabled or 2MPHY is selected, testing has shown that we need to
  //increase the size of the VSP Rx buffer otherwise things go pear shaped because we need to cater to
  // up to 6 (or more) packets to arrive in a single connection interval. In that case if there is no
  //space to save the new data, then then only option is to just dump it which is seen as a loss of data.
  //In future we can refactor the VSP functionality in this app by NOT using the BleVspXXX() helper functions
  //but leverage the fact that we now have the ability to send STRING data in event messages and so this
  //issue can only arise if the heap is running low.
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  if (startflags&0x78)!= 0 then
    //We need to increase the size of the VSP rxbuffer if it is too small
    tmpVar = 8 * DLE_ATTRIBUTE_SIZE
    if tmpVar > nArg[2] then
      nArg[2] = tmpVar
      #cmpif 0x00000004 : DbgMsgVal("Increased VSP Rxbuf Size to ", tmpVar)
    endif
  endif

  //Get UUID handles for Service and the 4 Characteristics
  tmpStr$ = SRegGetStr$( CfgIdStr_VspServiceUUID128)
  tmpStr$ = StrDehexize$(tmpStr$)
  nArg[3] = BleHandleUuid128(tmpStr$)  //VspServiceUuid
  nArg[4] = BleHandleUuidSibling(nArg[3], SRegGet(CfgId_VspRxUUID))
  nArg[5] = BleHandleUuidSibling(nArg[3], SRegGet(CfgId_VspTxUUID))
  nArg[6] = BleHandleUuidSibling(nArg[3], SRegGet(CfgId_VspMdmInUUID))
  nArg[7] = BleHandleUuidSibling(nArg[3], SRegGet(CfgId_VspMdmOutUUID))

  //Get EncryptionReq
  nArg[8] = SRegGet( CfgId_Encrypt)
endsub

//------------------------------------------------------------------------------
// Returns the number of trusted devices in the database
//------------------------------------------------------------------------------
function TrustedDevices()
endfunc SysInfo(2009)

//------------------------------------------------------------------------------
// Open VSP service using sArg$[] and nArg[] as per VspGetDefs()
//------------------------------------------------------------------------------
function VspOpen()
  dim vspFlags

  //Update VSP flags variable
  if ((nArg[8] & 0x1) == 0x1 ) then   //nArg[8] == CfgId_Encrypt :: Encrypt Bit
    //Connection encryption is enabled, get timer value
    encDisconTime = SRegGet( CfgId_EncrDisconToutMs)
    if ((nArg[8] & 0x2) == 0x2 ) then  //NArg[8] == CfgId_Encrypt :: MITM Bit
      //MITM required
      vspFlags = 0x0C
    else
      //MITM not required
      vspFlags = 0x08
    endif
    vspMinTrusted = 1
  else
    //VSP encryption is disabled, disable timer
    encDisconTime = 0
    vspFlags = 0
    vspMinTrusted = 0
  endif

  //Save the service UUID handle so that we can use it when creating the advert report
  handleVspServiceUuid = nArg[3]
  //Create UUID that will be advertised
  handleLteServiceUuid = BleHandleUuidSibling(handleVspServiceUuid, LAIRD_UUID_LTE_SERVICE)

  //Open the VSP service with the provided configuration
  #cmpif 0x00000004 : DbgMsgVal("VSP Txbuf Size ", nArg[1])
  #cmpif 0x00000004 : DbgMsgVal("VSP Rxbuf Size ", nArg[2])
  rc = BleVSPOpenEx(nArg[1], nArg[2], vspFlags, nArg[3], nArg[4], nArg[5], nArg[6], nArg[7])
  #cmpif 0x00000003 : AssertRC(17770)
  if rc == 0 then
    vspAdded = 1
    #cmpif 0x00000004 : DbgMsg("VSP Service Added")
  endif
endfunc rc

//------------------------------------------------------------------------------
// Create a generic minimal advert
//------------------------------------------------------------------------------
sub GenAdvCreateMinimal(byref advRpt$, byref scRpt$)
  dim flgsAD, nAppearance

  flgsAD      = SRegGet( CfgId_VspFlagsAD )
  nAppearance = SRegGet( CfgId_Appearance)

  rc = BleAdvRptInit(advRpt$, flgsAD, nAppearance, MaxDevNameSize)
    #cmpif 0x00000003 : AssertRC(17930)

  rc = BleScanRptInit(scRpt$)
    #cmpif 0x00000003 : AssertRC(17960)
endsub

//------------------------------------------------------------------------------
// The advert report for the VSP service
//------------------------------------------------------------------------------
sub VspAdvCreateCommit()
  //Add device name to advert report and service UUID to scan report
  dim advRpt$, scRpt$

  GenAdvCreateMinimal(advRpt$, scRpt$)

  #cmpif 0x00000003 : AssertNE(handleLteServiceUuid, 0, 10950)
  rc = BleAdvRptAddUuid128(scRpt$, handleLteServiceUuid)
  #cmpif 0x00000003 : AssertRC(18110)

  #cmpif 0x00000001 : print dbgStart$;"VspAdv ";strhexize$(advRpt$)
  #cmpif 0x00000001 : print dbgStart$;"VspScn ";strhexize$(scRpt$)

  rc = BleAdvRptsCommit(advRpt$, scRpt$)
  #cmpif 0x00000003 : AssertRC(18170)
endsub

//------------------------------------------------------------------------------
// BLE advertising for central devices to connect to for VSP service
//------------------------------------------------------------------------------
sub VspStartAdverts()
  dim Addr$
  Addr$ = ""

  rc = BleAdvertStart(0, Addr$, SRegGet(CfgId_VspAdvertIntvlMs), 0, 0)
  #cmpif 0x00000003 : AssertRC(18280)
  #cmpif 0x00000004 : DbgMsg("Vsp Adverts Started")
endsub

//------------------------------------------------------------------------------
// Create minimal idle advert/scan reports
//------------------------------------------------------------------------------
sub IdleAdvCreate()
  GenAdvCreateMinimal(idleAdvRpt$, idleScnRpt$)
endsub

//------------------------------------------------------------------------------
// Commit the idle mode advert reports
//------------------------------------------------------------------------------
sub IdleAdvCommit()

  #cmpif 0x00000001 : print dbgStart$;"IdlAdv ";strhexize$(idleAdvRpt$)
  #cmpif 0x00000001 : print dbgStart$;"IdlScn ";strhexize$(idleScnRpt$)

  rc = BleAdvRptsCommit(idleAdvRpt$, idleScnRpt$)
  #cmpif 0x00000003 : AssertRC(18480)
endsub

//------------------------------------------------------------------------------
// BLE advertising for central devices to connect to for VSP service
//------------------------------------------------------------------------------
sub IdleStartAdverts( advType, adIntervalMs )
  dim Addr$
  Addr$ = ""

  rc = BleAdvertStart(advType, Addr$, idleAdvIntvlMs , 0, 0)
  #cmpif 0x00000003 : AssertRC(18590)
  #cmpif 0x00000004 : DbgMsg("Idle Adverts Started")

  //Save in cache
  idleAdvType    = advType
  idleAdvIntvlMs = adIntervalMs
endsub

//------------------------------------------------------------------------------
// Set HL State on LTE_RESET release
//------------------------------------------------------------------------------
sub SetHlStateOnResetRel()
  //Initialise HL State
  if GpioRead(SIO_LTE_VGPIO) == 0 then
    NewHlState(HLSTATE_POSTRESET_WAIT_VGPIO)
  else
    //NewHlState(HLSTATE_POSTRESET_WAIT_CTS_DEASSERT)
    NewHlState(HLSTATE_POSTRESET_WAIT_DSR_DEASSERT)
  endif
endsub

//------------------------------------------------------------------------------
// Currently only need to initialise the GPIO for vspCmdMode Pin in Fast mode
// or when low power UART operation is compile time enabled then the same pin
// is used by the host to reopen the UART
//------------------------------------------------------------------------------
sub InitGPIO()

  // +++++++++
  // Disable QSPI_CS line and config all other pins as inputs with nopull
  rc = GpioSetFunc(SIO_QSPI_CS,        SIOTYPE_DOUT, (OUTPUT_DRIVE_S0S1+OUTPUT_INIT_HI )) //CS is low to enable
  #cmpif 0x00000003 : AssertRC(19010)
  rc = GpioSetFunc(SIO_QSPI_CLK,       SIOTYPE_DIN, INPUT_PULL_NONE)  //No pullup/pulldown
  #cmpif 0x00000003 : AssertRC(19012)
  rc = GpioSetFunc(SIO_QSPI_DIO0_MOSI, SIOTYPE_DIN, INPUT_PULL_NONE)  //No pullup/pulldown
  #cmpif 0x00000003 : AssertRC(19014)
  rc = GpioSetFunc(SIO_QSPI_DIO1_MISO, SIOTYPE_DIN, INPUT_PULL_NONE)  //No pullup/pulldown
  #cmpif 0x00000003 : AssertRC(19016)
  rc = GpioSetFunc(SIO_QSPI_DIO2,      SIOTYPE_DIN, INPUT_PULL_NONE)  //No pullup/pulldown
  #cmpif 0x00000003 : AssertRC(19018)
  rc = GpioSetFunc(SIO_QSPI_DIO3,      SIOTYPE_DIN, INPUT_PULL_NONE)  //No pullup/pulldown
  #cmpif 0x00000003 : AssertRC(19019)

  // +++++++++
  // Initialise the 840->HL78 reset output pins
  rc = GpioSetFunc(SIO_LTE_RESET,    SIOTYPE_DOUT, (OUTPUT_DRIVE_S0D1+OUTPUT_INIT_HI)) //RESET Deasserted
  #cmpif 0x00000003 : AssertRC(19090)
  nResetN = 1
  #cmpif 0x00000104 :   DbgMsg("LTE_RESET = 1")

  // +++++++++
  // Initialise other 840->HL78 interconnect output pins
  rc = GpioSetFunc(SIO_LTE_PWR_ON,   SIOTYPE_DOUT, (OUTPUT_DRIVE_S0D1+OUTPUT_INIT_HI)) //PWR_ON Deasserted
  #cmpif 0x00000003 : AssertRC(19130)
  nPwrOnN = 1
  #cmpif 0x00000104 :   DbgMsg("LTE_PWR_ON = 1")

  //Bug 14744 : Wake needs to be high by default
  rc = GpioSetFunc(SIO_LTE_WAKE,     SIOTYPE_DOUT, (OUTPUT_DRIVE_D0S1+OUTPUT_INIT_HI)) //WAKE asserted
  #cmpif 0x00000003 : AssertRC(19170)
  nWakeup = 1
  #cmpif 0x00000104 :   DbgMsg("LTE_WAKE_UP = 1")

  rc = GpioSetFunc(SIO_LTE_SHUTDOWN, SIOTYPE_DOUT, (OUTPUT_DRIVE_S0D1+OUTPUT_INIT_HI)) //SHUTDOWN Deasserted
  #cmpif 0x00000003 : AssertRC(19210)
  nFastShutDnN = 1
  #cmpif 0x00000104 :   DbgMsg("LTE_FASTSHUTDN = 1")

  rc = GpioSetFunc(SIO_LTE_UART1_DTR, SIOTYPE_DOUT, (OUTPUT_DRIVE_S0D1+OUTPUT_INIT_LOW)) //DTR asserted
  #cmpif 0x00000003 : AssertRC(19250)
  nUartDtr = 0
  #cmpif 0x00000104 :   DbgMsg("LTE_UART1_DTR = 0 (Asserted)")

  // +++++++++
  // Initialise the 840<-HL78 interconnect input pins
  rc = GpioSetFunc(SIO_LTE_TX_ON,     SIOTYPE_DIN, INPUT_PULL_NONE)  //no pullup/pulldown
  #cmpif 0x00000003 : AssertRC(19310)
  rc = GpioSetFunc(SIO_LTE_VGPIO,     SIOTYPE_DIN, INPUT_PULL_NONE)  //No pullup/pulldown
  #cmpif 0x00000003 : AssertRC(20140)

  // June 2019
  // Sierra document "2174229 - AirPrime_HL7800_Low_Power_Modes_Application_Note_Rev1_0.pdf"
  // page 15 has Figure 7 which shows trace lines of various i/o on the HL7800 and
  // for the GPIO2 trace there is a comment "Undefined state shall be connected to
  // an external pull down" hence the following statement makes that happen by
  // using the pulldown capability in 840 for any GPIO
  //
  rc = GpioSetFunc(SIO_LTE_GPIO2,     SIOTYPE_DIN, INPUT_PULL_DOWN)  //pulldown
  #cmpif 0x00000003 : AssertRC(20160)

  rc = GpioSetFunc(SIO_LTE_UART1_DSR, SIOTYPE_DIN, INPUT_PULL_NONE)  //No pullup/pulldown
  #cmpif 0x00000003 : AssertRC(20180)

  // +++++++++
  // Initialise the GPIO for low power UART operation mode Pin
  // operation is compile time enabled then the same pin is used by the host
  // to reopen the UART
  //
  //Cache the low power UART operation mode pin
  lowPowerModePin = SRegGet(CfgId_LowPowerPin)
  if lowPowerModePin>= 0 then
    #cmpif 0x00000004 : DbgMsgVal ("LowPowerCmdPin = ", lowPowerModePin)
    //And arrange so that we will get an event each time it goes from 0 to 1
    //because when that pin is high, it means host wants to force the UART to
    //be open
    rc = GpioSetFunc(lowPowerModePin, SIOTYPE_DIN, INPUT_PULL_NONE)
    #cmpif 0x00000003 :   AssertRC(18890)

    rc = GpioBindEvent(BINDEVENT_LOWPWR_UART, lowPowerModePin, DETECT_TOGGLE)
    #cmpif 0x00000003 :   AssertRC(18920)

    //Low power operation is enabled because pin has been specified
    fLowPwrUrtEnable = 1

    //Get low power idle timeout
    uartIdleToutMs = SRegGet(CfgId_UartIdleTime_ms)
    if uartIdleToutMs<MIN_IDLE_TIMEOUT_MS then
      uartIdleToutMs = MIN_IDLE_TIMEOUT_MS
    endif
    #cmpif 0x00000004 : DbgMsgVal ("IdleTimeout = ", uartIdleToutMs)
  endif
endsub

//------------------------------------------------------------------------------
// Common code when returning to one of the idle states
//------------------------------------------------------------------------------
sub IdleReturnAction()
  dim scanPat$
  #cmpif 0x00000004 : DbgMsgVal("IdleReturn - Radio", sysinfo(2016))
  #cmpif 0x00000004 : DbgMsgVal("OldIdleState = ", oldIdleState)

  select oldIdleState
  case STATE_IDLE_VSP
    //Create the VSP related Advert report and scan report and commit
    VspAdvCreateCommit()
    //Start Advertising
    VspStartAdverts()

  case STATE_IDLE_nonVSP
    advPrefix$ = "AD0:"

  case else
    //Nothing to do
    #cmpif 0x00000004 : DbgMsg("IdleReturn - unknown")
  endselect

  //Change state
  NewState(oldIdleState)
endsub

//------------------------------------------------------------------------------
// Called from a handler when VSP connection fails
//------------------------------------------------------------------------------
sub VspNoCarrierRet(rsp)
  IdleReturnAction()  //Will change state to one of IDLE, IDLE_VSP, IDLE_ADV

  //Send an NOCARRIER response
  AppendConnRspEnd(rsp, urtTxCache$)
  //Send out data waiting in buffer
  UartSendFrom840()
  //Also trigger a reprocessing of the UART buffer just in case
  rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
endsub

//------------------------------------------------------------------------------
// Called from a handler when nonVSP connection fails
//------------------------------------------------------------------------------
sub NonVspDisconRet(rsp, ndx)
  IdleReturnAction()  //Will change state to one of IDLE, IDLE_VSP, IDLE_ADV

  //Send an DISCON response
  SendNonVspDiscon(rsp, ndx, urtTxCache$)

  //Also trigger a reprocessing of the UART buffer just in case
  rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
endsub

//--------------------------------------------------------------------------
// Given a connection handle, returns 0 if not connected to a trusted device
// otherwise 1 for unauthenticated pairing and 2 for authenticated
// This is called on when making an outgoing VSP Connection
//--------------------------------------------------------------------------
function IsTrustedPeer(hConn)
  dim kInfo, rAge, rCount, klen
  dim curAddr$

  //Get address of connected device
  rc = BleGetAddrFromConnHandle(hConn, curAddr$)
  #cmpif 0x00000003 : AssertRC(20080)
  #cmpif 0x00000004 : dim a$ : a$ = StrHexize$(curAddr$)
  #cmpif 0x00000004 : DbgMsgVal$("Master Addr = ", a$)

  //Check if device is trusted
  klen = BleBondingIsTrusted(curAddr$, BOND_TRUSTED_AS_CENTRAL, kInfo, rAge, rCount)

  if klen > 0 then
    //It is trusted and for Phase 1 ignore the authentication stuff
    #cmpif 0x00000004 : print dbgStart$;"Peer is trusted "
    #cmpif 0x00000004 : if (kInfo & 0x1)!= 0 then
    #cmpif 0x00000004 :   print "(Authenticated)"
    #cmpif 0x00000004 : endif

    if (kInfo & BONDING_KEYINFO_MITM_AUTHENTICATED)!= 0 then
      //It is an authenticated bond, reuse kInfo variable for return value
      kInfo = 2
    else
      //It is not an authenticated bond, reuse kInfo variable for return value
      kInfo = 1
    endif
  else
    //Not trusted
    #cmpif 0x00000004 : print dbgStart$;"Peer is NOT trusted "
    kInfo = 0
  endif
endfunc kInfo

//------------------------------------------------------------------------------
// Open GATT client, returns a nonzero error code
//------------------------------------------------------------------------------
function GattClientOpen()
  if fGattClient == 0 then
    rc = BleGattcOpen(SRegGet(CfgId_GattClientMemSize), 0)
    if rc > 0 then
      rc = CONN_ERROR_OUTOFMEM
    else
      fGattClient = 1
      #cmpif 0x00000004 : DbgMsg("GattClientOpen")
    endif
  else
    rc = RSP_OK
      #cmpif 0x00000004 : DbgMsg("GattClient was Open")
  endif
endfunc rc

//------------------------------------------------------------------------------
// vspFindIndex is the index into the query array
//------------------------------------------------------------------------------
function FindCharOrDesc()
  //#cmpif 0x00000004 : DbgMsgVal("FindCharOrDesc Idx = ", vspFindIndex)

  dim cccdUuid : cccdUuid = hVspCccdUuids[vspFindIndex]
  dim charUuid : charUuid = nArg[vspFindIndex]

  if cccdUuid == 0 then
    //Find char
    //#cmpif 0x00000004 : DbgMsg("BleGattcFindChar")
    rc = BleGattcFindChar(connHandles[HCONN_VSP], vspSvcUuid, 0, charUuid, 0)
  else
    //Find desc
    //#cmpif 0x00000004 : DbgMsg("BleGattcFindDesc")
    rc = BleGattcFindDesc(connHandles[HCONN_VSP], vspSvcUuid, 0, charUuid, 0, cccdUuid, 0 )
  endif
  #cmpif 0x00000003 : AssertRC(20720)
endfunc rc

//------------------------------------------------------------------------------
// vspFindIndex is the index into the query array
// returns 0 if no more cccd's in the array
//------------------------------------------------------------------------------
function CccdsEnable()
  //#cmpif 0x00000004 : DbgMsgVal("CccdsEnable, idx = ", vspFindIndex)
  dim i, hAttr
  //First find the first cccd
  for i = vspFindIndex to (VSP_ATTR_MAX_INDEXES - 1)
    if hVspCccdUuids[i] != 0 then
      //This array index is for a cccd so get the attribute handle for it
      hAttr = hVspAttr[i]
      if hAttr != 0 then
        #cmpif 0x00000004 : print dbgStart$;"BleGattcWrite, hAttr = ";hAttr;" i = ";i
        //Found attr handle for a cccd
        tmpVar$ = "\01\00"
        rc = BleGattcWrite(connHandles[HCONN_VSP], hAttr, tmpVar$)
        #cmpif 0x00000003 : AssertRC(20930)
        vspFindIndex = i
        exitfunc 1
      endif
    endif
  next
  //Reaching here means no more cccd's to enable
endfunc 0

//------------------------------------------------------------------------------
// Setup array of chars+ desc that need to be found in the slave
//------------------------------------------------------------------------------
function GetVspHandles()
  dim i
  //Get VSP uuids and other values into nArg[]
  VspGetDefs()
  //   nArg[3]  = VspServiceUuid
  //   nArg[4]  = RxUUID       //0
  //   nArg[5]  = TxUUID       //1
  //   nArg[6]  = MdmInUUID    //2
  //   nArg[7]  = MdmOutUUID   //3
  vspSvcUuid = nArg[3]
  //Shuffle values in the nArg arrays as we are going to reuse it.
  for i = 0 to 3
    nArg[i] = nArg[i+4]
  next
  //   nArg[0]  = RxUUID/0          //0
  //   nArg[1]  = TxUUID/0          //1
  //   nArg[2]  = MdmInUUID/0       //2
  //   nArg[3]  = MdmOutUUID/0      //3
  //   nArg[4]  = TxUUID/CCCD       //4
  //   nArg[5]  = MdmOutUUID/CCCD   //5
  for i = 0 to (VSP_ATTR_MAX_INDEXES - 1)
    hVspCccdUuids[i] = 0
    hVspAttr[i] = 0  //Assume all are optinal
  next
  //The RX and TX characteristic are mandatory
  hVspAttr[VSP_ATTR_INDEX_RX]       = 1
  hVspAttr[VSP_ATTR_INDEX_TX]       = 1
  hVspAttr[VSP_ATTR_INDEX_TX_CCCD]  = 1
  //The TX is capable of being notified
  nArg[VSP_ATTR_INDEX_TX_CCCD]      = nArg[VSP_ATTR_INDEX_TX]   //UUID handle
  hVspCccdUuids[VSP_ATTR_INDEX_TX_CCCD] = BleHandleUuid16(0x2902)
  //The MdmOut is capable of being notified
  nArg[VSP_ATTR_INDEX_MDMOUT_CCCD]  = nArg[VSP_ATTR_INDEX_MDMOUT]  //UUID handle
  hVspCccdUuids[VSP_ATTR_INDEX_MDMOUT_CCCD] = hVspCccdUuids[VSP_ATTR_INDEX_TX_CCCD]

  //Now trigger the query to find the chars and descriptors
  vspFindIndex = 0
endfunc FindCharOrDesc()

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub VspEnterConnState(msgId)
  //We want ^^^ mode of operation
  #cmpif 0x00000004 :   DbgMsg("Going For PATCH")
  rc = SendMsgApp(msgId, STATE_VSP_PATCH_CONNECTED)
  #cmpif 0x00000003 : AssertRC(21500)

  //Negotiate ATT_MTU if ATS213 is not the default minimum value
  if vspIsOutGoing != FALSE then
    if vspAttrMaxLen > DEFAULT_ATTRIBUTE_SIZE then
      rc = BleGattcAttributeMtuRequest(connHandles[HCONN_VSP])
#cmpif 0x00000001 :  print dbgStart$;"BleGattcAttributeMtuRequest() ret:";integer.h' rc
    else
      rc = ChangePhy( connHandles[HCONN_VSP] )
#cmpif 0x00000001 :  print dbgStart$;"ChangePhy() ret:";integer.h' rc
    endif
  endif
#cmpif 0x00000040 : vtxcnt = 0 : vrxcnt = 0
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub OnVspConnCommon(hConn)
  connHandles[HCONN_VSP] = hConn
  vspDisconSts = -1 //Assume normal disconnection will happen
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
sub OnNonVspConnection(hConn)
  dim nodeIdx

  nodeIdx = GetFreeIdx()
  if nodeIdx == 0 then
    //Disconnect immediately
    rc = BleDisconnect(hConn)
    #cmpif 0x00000003 : AssertRC(21810)
  else
    //Cache the connection handle
    connHandles[nodeIdx] = hConn
    //Send an DISCON response
    SendNonVspConnect(nodeIdx, urtTxCache$)
    //Change state
    NewState(STATE_nonVSP_CONNECTED)
    //For now, do not process any incoming
       //
       //OnEvent EVATTRNOTIFY Disable
       //
    //need to process more
    rc = SendMsgApp(MSGAPP_ENTER_NONVSP_CONN_STATE, NULL_CTX)
  endif
endsub

//------------------------------------------------------------------------------
// Called on Connection
//------------------------------------------------------------------------------
function AllowPatchToAux()
  select muxMode
  case MULTIPLEXER_MODE_NONGPIO
    if muxState == MUX_STATE_1_840 then
      exitfunc 1
    endif

  case MULTIPLEXER_MODE_INTELLIGENT
    if muxState == MUX_STATE_2_840_IDLE then
      exitfunc 1
    endif

  case else
  endselect
endfunc 0  //Disallow

//------------------------------------------------------------------------------
// Called on Connection
//------------------------------------------------------------------------------
sub OnConnect(hConn)
  #cmpif 0x00000004 : DbgMsg("Connect")
  #cmpif 0x00000008 : ShowConnParms(hConn)

  //Increment the connection count
  connCount = connCount + 1

  select curState
  case STATE_IDLE_VSP
    //If not in GPIO mux mode then accept
    #cmpif 0x00000004 : DbgMsgVal("muxMode = ", muxMode)
    if AllowPatchToAux() then
      //Send a RING response because it is an incoming connection
      SendRingRsp(hConn, urtTxCache$  )
      //Action common stuff for VSP whether in our outgoing
      OnVspConnCommon(hConn)
      //Flush the VSP buffers just in case there is stuff from previous connections
      BleVspFlush(3)
      //Incoming VSP connection
      SaveState(oldIdleState)
      if encDisconTime != 0 then
        //We expect an encrypted connection
        #cmpif 0x00000004 : DbgMsgVal("Enc Required, Timer(ms) = ", encDisconTime)
        TimerStart(TMRNUM_ENCR_WAIT, encDisconTime, 0)
        NewState(STATE_VSP_IN_WAIT_ENCR)
      else
        //No encryption required for this connection
        #cmpif 0x00000004 : DbgMsg("Enc NOT Required")
        vspIsOutGoing = FALSE
        VspEnterConnState(MSGAPP_ENTER_VSPIN_CONN_STATE)
      endif
    else
      #cmpif 0x00000004 : DbgMsg("Vsp to Aux Patch not allowed")
      rc = BleDisconnect(hConn)
      //Change state
      NewState(STATE_VSP_IGNORED)
    endif

  case STATE_VSP_CONNECTING_OUTGOING
    //Action common stuff for VSP whether in our outgoing
    OnVspConnCommon(hConn)
    //Is this a trusted peer
    if IsTrustedPeer(hConn) > 0 then
      //Peer is trusted
      rc = BleEncryptConnection(hConn, LTK_MINIMUM_SIZE, BLE_ENCRYPT_MITM_NOT_REQUIRED)
      #cmpif 0x00000004 : DbgMsg("Encrypting..")
      //Change state
      NewState(STATE_VSP_WAIT_ENCRYPT)
    else
      //Peer is not trusted
      rc = GetVspHandles()
      //Change state
      NewState(STATE_VSP_GET_HANDLES)
    endif

  case STATE_IDLE_nonVSP
    //New connection so need to create a indx handle
    //incoming nonVSP connection
    SaveState(oldIdleState)
    OnNonVspConnection(hConn)

  case STATE_nonVSP_CONNECTING
    //New connection so need to create a indx handle
    OnNonVspConnection(hConn)

  case else
  endselect
endsub

//------------------------------------------------------------------------------
// Called on connection going encryted
//------------------------------------------------------------------------------
sub OnEncrypted(hConn)
  dim sndMsg : sndMsg = 1
  dim nIdx : nIdx = HCONN_VSP
  #cmpif 0x00000004 : DbgMsg("Encrypted")

  select curState
  case STATE_VSP_IN_WAIT_ENCR
    vspIsOutGoing = FALSE
    VspEnterConnState(MSGAPP_ENTER_VSPIN_CONN_STATE)

  case STATE_VSP_WAIT_ENCRYPT
    //Peer is not trusted
    rc = GetVspHandles()
    //Change state
    NewState(STATE_VSP_GET_HANDLES)

  case STATE_VSP_PAIRING
    //Successful just works pairing
    rc = CccdsEnable()
    //Change state
    NewState(STATE_VSP_WRITE_CCCDS)

  case STATE_nonVSP_CONNECTED
    nIdx = GetIdxFromHConn(hConn)
    sndMsg = 2

  case else
    sndMsg = 0
  endselect

  //Conditionally send "ENCRYPT" message
  SendEncryptRsp(nIdx, sndMsg, urtTxCache$ )
endsub

//------------------------------------------------------------------------------
// Called when connection failed to encrypt
//------------------------------------------------------------------------------
sub OnUnencrypted(hConn)

  #cmpif 0x00000004 : DbgMsg("Failed to Encrypt")

  select curState
  case STATE_VSP_WAIT_ENCRYPT, STATE_VSP_PAIRING
    vspDisconSts = CONN_ERROR_UNENCRYPTED
    //Some other error, so just drop the connection
    rc = BleDisconnect(hConn)
    //Change state
    NewState(STATE_VSP_DISCONNECTING)

  case STATE_nonVSP_CONNECTED
    //Some other error, so just drop the connection
    rc = BleDisconnect(hConn)
    //Remain in state

  case else
  endselect
endsub

//------------------------------------------------------------------------------
// Called when asked to display passkey which is in nCTx
//------------------------------------------------------------------------------
sub OnDisplayPasskey(nCtx)

  #cmpif 0x00000004 : DbgMsgVal("Display Passkey = ", nCtx)

  select curState
  case STATE_VSP_IN_WAIT_ENCR
    vspDisconSts = CONN_ERROR_PAIRUI
    //Some other error, so just drop the connection
    rc = BleDisconnect(connHandles[HCONN_VSP])
    //Change state
    NewState(STATE_VSP_DISCONNECTING)

  case STATE_nonVSP_CONNECTED
    SendDispPassKey(nCtx, urtTxCache$)

  case else
  endselect
endsub

//------------------------------------------------------------------------------
// Called when asked for auth key request. nCTx is type of key requested
//------------------------------------------------------------------------------
sub OnAuthKeyRequest(nCtx)

  #cmpif 0x00000004 : DbgMsgVal("Auth Key Request = ", nCtx)

  select curState
  case STATE_VSP_IN_WAIT_ENCR
    vspDisconSts = CONN_ERROR_PAIRUI
    //Some other error, so just drop the connection
    rc = BleDisconnect(connHandles[HCONN_VSP])
    //Change state
    NewState(STATE_VSP_DISCONNECTING)

  case STATE_nonVSP_CONNECTED
    SendAuthKeyReq(nCtx, urtTxCache$)

  case else
  endselect
endsub

//------------------------------------------------------------------------------
// Called from finddesc and findchar event handlers in VSP mode
//------------------------------------------------------------------------------
sub SvcFindCharDescEv(hConn, hAttr)

  if hAttr == 0 then
    //Did not find the attribute, so check if it was mandatory
    if hVspAttr[vspFindIndex] != 0 then
      //This was a mandatory attribute so something went wrong hence abort
      vspDisconSts = CONN_ERROR_NOVSPSERVICE
      //Some other error, so just drop the connection
      rc = BleDisconnect(hConn)
      //Change state
      NewState(STATE_VSP_DISCONNECTING)
      exitsub
    endif
  endif

  //Save the attribute and check if more to find
  hVspAttr[vspFindIndex] = hAttr
  if vspFindIndex>= (VSP_ATTR_MAX_INDEXES-1) then
    //This is for the last item in the query table
    vspFindIndex = 0
    rc = CccdsEnable()
    #cmpif 0x00000003 : AssertNE(rc, 0, 13470)
    //Change state
    NewState(STATE_VSP_WRITE_CCCDS)
  else
    //More to look for
    vspFindIndex = vspFindIndex + 1
    rc = FindCharOrDesc()
    //Remain in this state
  endif
endsub

//------------------------------------------------------------------------------
// Returns 1 if nSts from AttrWrite means 'encrypted link required'
//------------------------------------------------------------------------------
function Is_Encr_Required(xSts)
  select xSts
  case 0x105, 0x010F, 0x0111
    //0x105 = Authenticated link required
    //0x10F = Encrypted link required
    //0x111 = Encrypted link required
    exitfunc 1
  case else
  endselect
endfunc 0

//------------------------------------------------------------------------------
// Called only when VSP in master mode (Out)
//------------------------------------------------------------------------------
sub VspMasterRtsSend(nState)
    if hVspAttr[VSP_ATTR_INDEX_MDMIN] then
      if nState != vspAllowRx then
        if nState then
          tmpVar$ = "\01"
        else
          tmpVar$ = "\00"
        endif
        rc = BleGattcWriteCmd(connHandles[HCONN_VSP], hVspAttr[VSP_ATTR_INDEX_MDMIN], tmpVar$)
        if rc == 0 then
          vspAllowRx = nState
        endif
      endif
    endif
endsub


//------------------------------------------------------------------------------
// Initialise and cache uart/aux parameters from S-registers
//------------------------------------------------------------------------------
sub InitUrtAuxCache()

  //.............................................................
  //Main UART Port
  //.............................................................
  urtFlow     = SRegGet( CfgId_UartFlowControl )
  urtBaud     = SRegGet( CfgId_UARTBaudrate )
  urtTxBufLen = SRegGet( CfgId_UARTTxBufSize )
  urtRxBufLen = SRegGet( CfgId_UARTRxBufSize )

             //     RTS   CTS
             //     |  TX |  RX
             //     |  |  |  |
  urtOption$ = "CN81H\05\06\07\08\00"  //Break will result in DEEP SLEEP

  //Update the flow control character in the option string
  if urtFlow then
    rc = BleEncode8(urtOption$, CHR_ASCII_H, 4)
  else
    rc = BleEncode8(urtOption$, CHR_ASCII_N, 4)
    #cmpif 0x00000004 : DbgMsg("Urt HW Flow Disabled")
  endif

  //.............................................................
  //auxiliary Port connected to HL78
  //.............................................................
  auxFlow = urtFlow
  auxBaud = urtBaud
  auxTxBufLen = SRegGet( CfgId_AuxTxBufSize )
  auxRxBufLen = SRegGet( CfgId_AuxRxBufSize )

             //     RTS   CTS   BREAKevents
             //     |  TX |  RX |  CTSevents
             //     |  |  |  |  |  |
  auxOption$ = "CN81H\0D\0E\0F\10\02\01"  //Break results in an EVAUXBREAK event and CTS events

  //Update the flow control character in the option string
  if auxFlow then
    rc = BleEncode8(auxOption$, CHR_ASCII_H, 4)
  else
    rc = BleEncode8(auxOption$, CHR_ASCII_N, 4)
    #cmpif 0x00000004 : DbgMsg("Aux HW Flow Disabled")
  endif
endsub

//------------------------------------------------------------------------------
// Initialise the UART
//------------------------------------------------------------------------------
sub InitUART()
  //Sets up the UART to use the required baud rate, flow control and parity options

  rc = UARTInfo(0)
  if (rc != 0) then
      //UART is opened, close
      UARTClose()
  endif

  //Config the main UART pins as inputs with no pull
  rc = GpioSetFunc(UART_SIONUM_RX, SIOTYPE_DIN, INPUT_PULL_NONE)
  #cmpif 0x00000003 : AssertRC(25620)
  rc = GpioSetFunc(UART_SIONUM_CTS, SIOTYPE_DIN, INPUT_PULL_NONE)
  #cmpif 0x00000003 : AssertRC(25640)
  rc = GpioSetFunc(UART_SIONUM_TX, SIOTYPE_DIN, INPUT_PULL_NONE)
  #cmpif 0x00000003 : AssertRC(25660)
  rc = GpioSetFunc(UART_SIONUM_RTS, SIOTYPE_DIN, INPUT_PULL_NONE)
  #cmpif 0x00000003 : AssertRC(25680)

  //Reopen the UART with comms parms from S Registers
  OpenMainUart()
endsub

//------------------------------------------------------------------------------
// Load GAP service defaults into sArg$[] and nArg[] to set things up as follows
//   sArg$[0] = device name
//   nArg[1]  = MinConnInterval
//   nArg[2]  = MaxConnInterval
//   nArg[3]  = LinkSupervisionTimeout
//   nArg[4]  = Appearance
//   nArg[5]  = Slave Latency
//   nArg[6]  = DeviceName is writeable
//------------------------------------------------------------------------------
sub GapServiceGetDefs()
  dim tmpStr$, tmpVar

  //Get device name
  sArg$[0] = SRegGetStr$( CfgIdStr_DeviceName )
  //Append part of module BT address if required
  tmpVar = SRegGet( CfgId_DevNameFormat)
  #cmpif 0x00000004 : DbgMsgVal("DevNameFormat = ", tmpVar)
  //Default selection if the BT address is appended to the advertised device name
  if ((tmpVar >= 1) && (tmpVar <= 7)) then
    //Get device address
    tmpStr$ = SysInfo$(4)
    #cmpif 0x00000004 : dim x$ : x$ = strhexize$(tmpStr$)
    #cmpif 0x00000004 : DbgMsgVal$("SysInfo$(4) = ", x$)
    tmpStr$ = Right$(tmpStr$, tmpVar)
    //Append to device name
    sArg$[0] = sArg$[0] + "-" + strhexize$(tmpStr$)
  endif
  //Take the right-most max characters
  sArg$[0] = right$(sArg$[0], MaxDevNameSize)

  #cmpif 0x00000004 : DbgMsgVal$("DeviceName = ", sArg$[0])

  //Set the max Tx power level
  tmpVar = SRegGet( CfgId_TxPower_dBm )
  rc = BleTxPowerSet(tmpVar)
  #cmpif 0x00000003 : AssertRC(25660)
  #cmpif 0x00000004 : DbgMsgVal("Max TxPwr = ", tmpVar)

  //Set the max Tx power level for pairing
  tmpVar = SRegGet( CfgId_PairingTxPower_dBm )
  rc = BleTxPwrWhilePairing(tmpVar)
  #cmpif 0x00000003 : AssertRC(25720)
  #cmpif 0x00000004 : DbgMsgVal("Max Pairing TxPwr = ", tmpVar)

  //Set min/max connection intervals
  nArg[1] = CONN_INTERVAL_MIN_ASPERIPH_US
  nArg[2] = CONN_INTERVAL_MAX_ASPERIPH_US
  nArg[3] = SRegGet( CfgId_LinkSupervsnAsSlaveSec) * 1000000

  //Read the Slave latency
  nArg[5] = SRegGet( CfgId_SlaveLatency)
  tmpVar = nArg[3] / nArg[2] - 1    //LinkSuprvsnTouUs/MaxConnIntUs
  if nArg[5] > tmpVar then
    nArg[5] = tmpVar   //Slave latency has to be compatible with slave latency
  endif

  //Read the appearance
  nArg[4] = SRegGet( CfgId_Appearance)

  //Writeable device name is disabled for now
  nArg[6] = 0
endsub

//------------------------------------------------------------------------------
// Initialise the GAP service, uses sArg$[] and nArg[] setup using
// GapServiceGetDefs() and/or AT command line
//------------------------------------------------------------------------------
function GapServiceUpdate()
  //Initialise the GAP service with the connection interval data and device name
  rc = BleGapSvcInit(sArg$[0], nArg[6], nArg[4], nArg[1], nArg[2], nArg[3],  nArg[5])
  #cmpif 0x00000003 : AssertRC(26010)
endfunc rc

//------------------------------------------------------------------------------
// Configure the pairing capability as set via the S registers
//------------------------------------------------------------------------------
sub PairingConfig()
  //Set the IO Capability
  pairIoCapCache = SRegGet(CfgId_PairingIoCapability)
  rc = BleSecMngrIoCap(pairIoCapCache)
  #cmpif 0x00000003 : AssertRC(26110)

  //Enable LESC preference
  rc = BleSecMngrLescPairingPref(1)
  #cmpif 0x00000003 : AssertRC(26150)
endsub

//------------------------------------------------------------------------------
// Read, Cache & Config Scanning Parameters
//------------------------------------------------------------------------------
sub CacheConfigScanParms()
  scanIntervalMs = SRegGet(CfgId_ScanInterval_ms)
  scanWindowMs   = SRegGet(CfgId_ScanWindow_ms)
  scanType       = SRegGet(CfgId_ScanType)

  //Ensure that the window is sensible
  if scanWindowMs > scanIntervalMs then
    scanWindowMs = scanIntervalMs
  endif

  //And finally set them
  rc = BleScanConfig(0, scanIntervalMs)
  #cmpif 0x00000003 : AssertRC(26330)
  rc = BleScanConfig(1, scanWindowMs)
  #cmpif 0x00000003 : AssertRC(26350)
  rc = BleScanConfig(2, scanType)
  #cmpif 0x00000003 : AssertRC(26370)
endsub

//------------------------------------------------------------------------------
// Extract exactly one parameter which MUST be a valid 14 hex digit address
//------------------------------------------------------------------------------
function ExtractAddr(byref cmdStr$)  //sArg$[0] is updated with address
  dim args
  rc = ExtractArgsCSV(cmdStr$, args, 1, 1)
  if rc == 0 then
    //The supplied parameter must dehex to exactly 7 bytes
    sArg$[0] = StrDehexize$(sArg$[0])
    if strlen(sArg$[0]) != 7 then
      //A valid address has not been supplied
      exitfunc CONN_ERROR_INVALID_ADDRESS
    endif
  endif
endfunc RSP_OK

//------------------------------------------------------------------------------
// Extract addr and load other connection related variables
//------------------------------------------------------------------------------
function ConnSetup(byref cmdStr$)

  //Stop adverts if on
  AdvertsStop()
  //Stop Scanning if on
  ScanningStop()

  //Try to open the GATT client
  rc = GattClientOpen()
  if rc!= 0 then
    exitfunc rc
  endif

  //Extract the mac address of the peer to connect to
  rc = ExtractAddr(cmdStr$) //sArg$[0] is updated with address
  if rc != 0 then
    exitfunc rc
  endif

  //Read the min & max connection intervals
  nArg[1] = SRegGet( CfgId_MinConnIntUs)
  nArg[2] = SRegGet( CfgId_MaxConnIntUs)
  if nArg[1] > nArg[2] then
     //Check the values are sensible
     nArg[1] = nArg[2]
  endif

  //Read the link supervision timeout
  nArg[3] = SRegGet( CfgId_LinkSuprvsnToutMs) * 1000
  if nArg[3] < nArg[2] then
    nArg[3] = nArg[2] + 1000000   //Add a second to the max interval
  endif

  //Get connection timeout from s register
  nArg[0] = SRegGet( CfgId_ConnTimeoutSec ) * 1000

  #cmpif 0x00000004 :     DbgMsg("Conn Parms")
  #cmpif 0x00000004 :  DbgMsgVal("  Conn Tout(msec) = ", nArg[0])
  #cmpif 0x00000004 :  DbgMsgVal("  Min Intvl      = ", nArg[1])
  #cmpif 0x00000004 :  DbgMsgVal("  Max Intvl      = ", nArg[2])
  #cmpif 0x00000004 :  DbgMsgVal("  Link Suprvsn   = ", nArg[3])

  //OK to start an outgoing connection
  rc = BleConnect(sArg$[0], nArg[0] , nArg[1], nArg[2], nArg[3] )
  if rc!= 0 then
    #cmpif 0x00000004 : DbgMsgVal ("BleConnect failed with", rc)
    exitfunc CONN_ERROR_BLECONNECT
  endif
  #cmpif 0x00000004 : DbgMsg("Connecting..")
endfunc rc

//==============================================================================
//==============================================================================
#cmpif 0x00020000 : function InitiateTableMap(hConn)
#cmpif 0x00020000 :   rc = BleDiscServiceFirst(hConn, 0, 0)
#cmpif 0x00020000 :   if rc == 0 then
#cmpif 0x00020000 :     exitfunc -1
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 : endfunc rc

//==============================================================================
//==============================================================================
#cmpif 0x00020000 : sub TerminateTableMap(rc)
#cmpif 0x00020000 :   if rc == 0x6052 then
#cmpif 0x00020000 :     //0x6052 = BLE_GATTC_NO_MORE_DATA
#cmpif 0x00020000 :     rc = 0
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 :   AppendRspEnd(rc, urtTxCache$)
#cmpif 0x00020000 :   //Send out data waiting in buffer
#cmpif 0x00020000 :   UartSendFrom840()
#cmpif 0x00020000 : endsub

//------------------------------------------------------------------------------
// Open the AUX serial port
//------------------------------------------------------------------------------
sub OpenAuxPort()
  dim nSio, nSioCts

  //If the Aux is open close it
  if AuxInfo(0) then
    //Open so first ensure the aux is closed
    AuxClose()
  endif

  //-----------------------------------------------------------------------------
  //To regression test the uart/aux multiplexer we need to feed various responses
  //into the AUX port as if it was coming from the HL78.
  //Without a cellular network it is difficult to test all the scenarios and so
  //StringPlayer/UwTerminalX is used to feed those signals and so diverting aux
  //to alternate pins makes it easier and that happens when cmpif bit 0x40000000
  //is set
  //-----------------------------------------------------------------------------

  //RTS line - Out
  nSioRts = SIO_AUX_RTS
  #cmpif 0x40000000 : nSioRts = SIO_AUX_RTS_REGRTEST
  //When closed ensure RTS line is an input with no pull
  rc = GpioSetFunc(nSioRts, SIOTYPE_DIN, INPUT_PULL_NONE)
  rc = BleEncode8(auxOption$, nSioRts, 5)

  //TXD line - Out
  nSioTx = SIO_AUX_TXD
  #cmpif 0x40000000 : nSioTx = SIO_AUX_TXD_REGRTEST
  //When closed ensure TXD line is an input with no pull
  rc = GpioSetFunc(nSioTx, SIOTYPE_DIN, INPUT_PULL_NONE)
  rc = BleEncode8(auxOption$, nSioTx, 6)

  //CTS line - In
  nSioCts = SIO_AUX_CTS
  #cmpif 0x40000000 : nSioCts = SIO_AUX_CTS_REGRTEST
  //When closed ensure CTS line is an input with no pull
  rc = GpioSetFunc(nSioCts, SIOTYPE_DIN, INPUT_PULL_NONE)
  rc = BleEncode8(auxOption$, nSioCts, 7)

  //RXD line - In
  nSio = SIO_AUX_RXD
  #cmpif 0x40000000 : nSio = SIO_AUX_RXD_REGRTEST
  //When closed ensure RXD line is an input with no pull
  rc = GpioSetFunc(nSio, SIOTYPE_DIN, INPUT_PULL_NONE)
  rc = BleEncode8(auxOption$, nSio, 8)

  //Finally open the aux port
  rc = AuxOpen(auxBaud, auxTxBufLen, auxRxBufLen, auxOption$)
  #cmpif 0x00000003 : AssertRC(27840)
  #cmpif 0x00000004 : tmpVar$ = strescape$(auxOption$)
  #cmpif 0x00000004 : DbgMsgVal$("Aux Open with Config", tmpVar$)

  if rc == 0 then
    //Switch on the xtal
    SetXtalHfClock(TRUE)
  endif

  //If flow control is not enabled then config RTS and CTS appropriately
  if auxFlow == 0 then
    rc = GpioSetFunc(nSioRts, SIOTYPE_DOUT, OUTPUT_INIT_LOW)  //Assert RTS
    rc = GpioSetFunc(nSioCts, SIOTYPE_DIN, INPUT_PULL_DOWN)   //Assert CTS via pulldown
  endif

  //Cache the current state of the CTS line from HL78
  hlUartCts = AuxInfo(7)
endsub

//------------------------------------------------------------------------------
// Called to clean-up when the app stops running
//------------------------------------------------------------------------------
sub OnAppExit( exType )
    if exType then
      //Send an OK response
      AppendRspEnd(RSP_OK, urtTxCache$)
    endif
endsub

//------------------------------------------------------------------------------
// This function is called when DTR output changes due to AT+CDTR or input
// or when the CTS input from the HL changes state.
//------------------------------------------------------------------------------
sub UpdateHlSleepOutput()
  hl78Sleeping = nUartDtr && hlUartCts
  #cmpif 0x02000000    : if hl78Sleeping == 0 then
  #cmpif 0x02000000    :   //Hl is not sleeping, we need to force the 840 to wake up
  #cmpif 0x02000000    :   UartReOpen()
  #cmpif 0x02000000    :   AuxReOpen()
  #cmpif 0x02000000    :   //#cmpif 0x00000104 :   DbgMsg("Uart/Aux reopened B")
  #cmpifand 0x02000004 : else
  #cmpifand 0x02000004 :   //Hl is sleeping, only print message if we uarts are open
  #cmpifand 0x02000004 :   if UartInfo(0) then
  #cmpifand 0x02000004 :     DbgMsg("HL Sleep")
  #cmpifand 0x02000004 :   endif
  #cmpif 0x02000000    : endif
endsub

//------------------------------------------------------------------------------
// Returns 0 if there is no VSP connection
//         1 if VSP tunnel to HL
//------------------------------------------------------------------------------
function IsVspTunneledToHL()
  if curState == STATE_VSP_PATCH_CONNECTED then
    exitfunc 1
  endif
endfunc 0

//##############################################################################
//##############################################################################

//------------------------------------------------------------------------------
// Process ATI command
//:/ATIn
//:/ == = =
//:/
//:/
//------------------------------------------------------------------------------
function _ati(byref cmdStr$, byref rspBuf$)
  dim args
  rc = ExtractArgsCSV(cmdStr$, args, 0, 1)
  if rc != 0 then
    exitfunc rc
  endif
  if args > 0 then
    if ExtractIntToken(sArg$[0], nArg[0]) == 0 then
      exitfunc RSP_ERROR_SYNTAX_ERROR
    endif
  else
    nArg[0] = 0
  endif

  select nArg[0]
  case 0
    tmpVar$ = ATI_RESPONSE_0
    #cmpif 0x10000000 : tmpVar$ = tmpVar$ + "\r\n(STD nAUTORUN)\r"

  case 3
    GetFirmwareVersion(tmpVar$)

  case 4
    tmpVar$ = SysInfo$(4)
    tmpVar$ = strhexize$(tmpVar$)

  case 10
    tmpVar$ = ATI_RESPONSE_10

  case 13
    sprint #tmpVar$, integer.h' sysinfo(1000)

  case 23
    tmpVar$ = LibVer

  case 33
    tmpVar$ = AppVer

  case 42
    sprint #tmpVar$, curState

  case 43
    sprint #tmpVar$, "D";nUartDtr;" P";nPwrOnN;" W";nWakeup;" F";nFastShutDnN;" R";nResetN

  #cmpif 0x00200000 : case 50
  #cmpif 0x00200000 :   sprint #tmpVar$, nfcSenseCnt
  #cmpif 0x00200000 :   nfcSenseCnt = nfcSenseCnt & 1
  #cmpif 0x00200000 :
  #cmpif 0x00200000 : case 51
  #cmpif 0x00200000 :   sprint #tmpVar$, nfcReadCnt
  #cmpif 0x00200000 :   nfcReadCnt = 0

  case else
    sprint #tmpVar$, sysinfo(nArg[0])

  endselect

  //Append to buffer
  rspBuf$ = rspBuf$ + rspStart$ + tmpVar$ + rspTerm$
endfunc RSP_OK

//------------------------------------------------------------------------------
// Process ATS command
//:/ATSn = m
//:/ATSn?
//:/ATSn = ?
//:/
//:/
//------------------------------------------------------------------------------
function _ats(byref cmdStr$, byref rspBuf$)
  //Extract the s-reg number
  if ExtractIntToken(cmdStr$, nArg[0]) == 0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  //Extract either = or ?
  if ExtractStrToken(cmdStr$, sArg$[1]) == 0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  rc = RSP_ERROR_SYNTAX_ERROR  //Assume syntax error
  if strcmp(sArg$[1], "?") == 0 then
    //Get the value of an S register
    if ExtractStrToken(cmdStr$, sArg$[1]) == 0 then
      //Rest of cmd string is empty
      rc = ATSRegGetValue(nArg[0], rspBuf$)
    endif
  elseif strcmp(sArg$[1], " = ") == 0 then
    //An assignment or get range
    if ExtractIntToken(cmdStr$, nArg[2]) == 0 then
      //Not an integer so try to extract a string
      if ExtractStrToken(cmdStr$, sArg$[2])>0 then
        if strcmp(sArg$[2], "?") == 0 then
          //Range query
          rc = ATSRegGetRange(nArg[0], rspBuf$)
        endif
      endif
    else
      //Got an integer
      if ExtractStrToken(cmdStr$, sArg$[3]) == 0 then
        //Rest of cmd string is empty
        #cmpif 0x00000004 : sprint #dbgmsg$, "\n##SetReg ";nArg[0];" ";nArg[2]
        #cmpif 0x00000004 : DbgMsg(dbgmsg$)
        rc = ATSRegSetValue(nArg[0], nArg[2])
      endif
    endif
  endif
endfunc rc

//------------------------------------------------------------------------------
// Process AT%S command
//:/AT%Sn = SomeStringValueInOptionalDoubleQuotes
//:/AT%Sn?
//:/AT%Sn = ?
//:/
//:/
//------------------------------------------------------------------------------
function _atsSTR(byref cmdStr$, byref rspBuf$)
  //Extract the s-reg number
  if ExtractIntToken(cmdStr$, nArg[0]) == 0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  //Extract either = or ?
  if ExtractStrToken(cmdStr$, sArg$[1]) == 0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  rc = RSP_ERROR_SYNTAX_ERROR  //Assume syntax error
  if strcmp(sArg$[1], "?") == 0 then
    //Get the value of an S register
    if ExtractStrToken(cmdStr$, sArg$[1]) == 0 then
      //Rest of cmd string is empty
      rc = ATSRegGetValueStr(nArg[0], rspBuf$)
    endif
  elseif strcmp(sArg$[1], " = ") == 0 then
    //An assignment or get range
    if ExtractStrToken(cmdStr$, sArg$[2])>0 then
      if strcmp(sArg$[2], "?") == 0 then
        //Range query
        rc = ATSRegGetLenRangeStr(nArg[0], rspBuf$)
      else
        if IsQuoted(sArg$[2]) then  //Check for beginning " and ending "
          //the string is quoted, so set it
          TrimQuotes(sArg$[2])
          rc = ATSRegSetValueStr(nArg[0], sArg$[2])
        endif
      endif
    endif
  endif
endfunc rc

//------------------------------------------------------------------------------
// Save registers to non-vol memory
//------------------------------------------------------------------------------
function _atampW(byref cmdStr$, byref rspBuf$)
  //Extract something and there should be nothing
  if ExtractStrToken(cmdStr$, tmpVar$)!= 0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
endfunc SRegSave()

//------------------------------------------------------------------------------
// Reset all non-vol data to factory settings and then reset
//------------------------------------------------------------------------------
function _atampF(byref cmdStr$, byref rspBuf$)
  //Extract something and there should be nothing
  if ExtractStrToken(cmdStr$, tmpVar$)!= 0 then
    exitfunc RSP_ERROR_SYNTAX_ERROR
  endif
  rc = SRegFactoryDef()
  if rc == RSP_OK then
    reset(0)
  endif
endfunc rc

//------------------------------------------------------------------------------
//:/ at+siorN       - read
//:/ at+siowN, V     - write
//:/ at+siocN, F, S   - config   F = 1(DIG_IN), 2(DIG_OUT) 3(ANALOG_IN)
//                             (see appropriate value of S in module user guide)
//------------------------------------------------------------------------------
function _atPlusSIO(byval actType, byref cmdStr$, byref rspBuf$)
  dim args
  rc = ExtractArgsCSV(cmdStr$, args, 1, 3)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  //Extract the sio number
  rc = SArgConvertToInt(0, 0, 0, MAX_SIO_NUM)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //At this point rc == RSP_OK

  select actType
  case 0 //READ
    //append to buffer
    //#cmpif 0x00000004 :  print dbgStart$;"SIO read ";nArg[0]
    sprint #tmpVar$, GpioRead(nArg[0])
    rspBuf$ = rspBuf$ + rspStart$ + tmpVar$ + rspTerm$

  case 1 //WRITE
    if args == 2 then
      rc = SArgConvertToInt(1, 0, 0, 0x7FFF)
      if rc!= RSP_OK then
        exitfunc rc
      endif
      //At this point rc == RSP_OK
      //#cmpif 0x00000004 :  print dbgStart$;"SIO write ";nArg[0], nArg[1]
      GpioWrite(nArg[0], nArg[1])
    else
      rc = RSP_ERROR_SYNTAX_ERROR
    endif

  case 2 //CONFIG
    if args == 3 then
      rc = SArgConvertToInt(1, 1, 1, 3)
      if rc!= RSP_OK then
        exitfunc rc
      endif
      //At this point rc == RSP_OK
      rc = SArgConvertToInt(2, 0, 0, 255)
      if rc!= RSP_OK then
        exitfunc rc
      endif
      //Disallow certain pins to be configured
      select nArg[0]
      case SIO_LTE_RESET, SIO_LTE_PWR_ON, SIO_LTE_WAKE, SIO_LTE_SHUTDOWN, SIO_LTE_UART1_DTR, SIO_LTE_TX_ON, SIO_LTE_TX_ON
        rc = RSP_ERROR_GPIO_NOT_AVAILABLE
      case else
        //At this point rc == RSP_OK
        //#cmpif 0x00000004 :  print dbgStart$;"SIO config ";nArg[0], nArg[1], nArg[2]
        rc = GpioSetFunc(nArg[0], nArg[1], nArg[2])
      endselect
    else
      rc = RSP_ERROR_SYNTAX_ERROR
    endif

  case else
    rc = RSP_ERROR_GPIO_NOT_AVAILABLE
  endselect
endfunc rc

//------------------------------------------------------------------------------
//:/ at+lscn<timeout_seconds><, "escaped_pattern"><, rssi>
//:/ at+lscn<x>
//------------------------------------------------------------------------------
function _atPlusLSCN(byref cmdStr$, byref rspBuf$)
  dim args
  sArg$[0] = ""
  rc = ExtractArgsCSV(cmdStr$, args, 0, 3)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //#cmpif 0x00000004 : DbgMsgVal ("args = ", args)
  //#cmpif 0x00000004 : DbgMsgVal$("sArg$[0] = ", sArg$[0])
  //#cmpif 0x00000004 : DbgMsgVal$("sArg$[1] = ", sArg$[1])
  //#cmpif 0x00000004 : DbgMsgVal$("sArg$[2] = ", sArg$[2])
  //#cmpif 0x00000004 : DbgMsgVal$("sArg$[3] = ", sArg$[3])

  //Check if this is to stop scanning ( AT+LSCNX )
  if (args == 1) then
    StrToLower$(sArg$[0])
    if strcmp(sArg$[0], "x") == 0 then
      ScanningStop()
      exitfunc RSP_OK
    endif
  endif

  //Get timeout into nArg[0]
  rc = SArgConvertToInt(0, SRegGet( CfgId_ScanTimeoutSec ), 0, SREG_ScanTimeoutSec_MAX)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  //Get Scan Pattern
  StrDeEscape(sArg$[1])  //ensure escaped characters are converted to binary

  //Get minimum RSSI threshold
  rc = SArgConvertToInt(2, -128, -128, 20)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  //And now start scanning
  select curState
  case STATE_IDLE_nonVSP
    //Scan timeout has to be specified in milliseconds
    //now start scanning with new parameters
    rc = ScanningStart((nArg[0] * 1000), sArg$[1], nArg[2])
    advPrefix$ = "AD0:"
    rc = RSP_OK

  case STATE_IDLE_VSP
    if nArg[0] == 0 then
      //Permanent scanning requested
      rc = ScanningStart(0, sArg$[1], nArg[2])
      //Change state
      advPrefix$ = "AD0:"
      NewState(STATE_IDLE_nonVSP)
      rc = RSP_OK
    else
      //Scan timeout has to be specified in milliseconds
      //if advertising and/or scanning in progress stop them
      AdvertsStop()
      //Now start scanning with new parameters
      rc = ScanningStart((nArg[0] * 1000), sArg$[1], nArg[2])
      if rc == 0 then
        //Successfully started scanning
        advPrefix$ = "AD1:"
        SaveState(oldIdleState)
        NewState(STATE_SCAN_VSP)
        //And suspend parser
        rc = RSP_SUSPEND
      endif
    endif

  case STATE_nonVSP_CONNECTED
    if nArg[0] == 0 then
      //Do not allow unlimited timeout scanning
      rc = RSP_ERROR_VALUE_NOT_VALID
    else
      //If advertising and/or scanning in progress stop them
      AdvertsStop()
      //Now start scanning with new parameters
      rc = ScanningStart((nArg[0] * 1000), sArg$[1], nArg[2])
      if rc == 0 then
        //Successfully started scanning
        advPrefix$ = "AD2:"
        //Remain in this state
      endif
    endif

  case else
    rc = RSP_ERROR_INCORRECT_MODE
  endselect
endfunc rc

//------------------------------------------------------------------------------
//:/ at+ladv<advType><, advIntervalMs>
//:/ at+ladv<x>
//------------------------------------------------------------------------------
function _atPlusLADV(byref cmdStr$, byref rspBuf$)
  dim args
  //This command has up to 2 parameters
  rc = ExtractArgsCSV(cmdStr$, args, 0, 2)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  //Check if this is to stop advertising ( AT+LADVX )
  if (args == 1) then
    StrToLower$(sArg$[0])
    if strcmp(sArg$[0], "x") == 0 then
      AdvertsStop()
      if curState == STATE_IDLE_VSP then
        //Only change state if we are in VSP Idle
        NewState(STATE_IDLE_nonVSP)
      endif
      exitfunc RSP_OK
    endif
  endif

  //Get advtype into nArg[0]
  rc = SArgConvertToInt(0, idleAdvType, SREG_IdleAdvertType_MIN, SREG_IdleAdvertType_MAX)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  if nArg[0] == 1 then
    exitfunc RSP_ERROR_ADV_TYPE
  endif

  //Get adv interval milliseconds into nArg[1]
  rc = SArgConvertToInt(1, idleAdvIntvlMs, SREG_IdleAdvertIntvlMs_MIN, SREG_IdleAdvertIntvlMs_MAX)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  //If advertising in progress stop it
  AdvertsStop()
  //Need to start advertising in idle
  IdleAdvCommit()
  //Start Advertising
  IdleStartAdverts(nArg[0], nArg[1])
  if curState == STATE_IDLE_VSP then
    //Only change state if we are in VSP Idle
    NewState(STATE_IDLE_nonVSP)
  endif
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+lVSP
//------------------------------------------------------------------------------
function _atPlusLVSP(byref cmdStr$, byref rspBuf$)
  dim args
  //This command has no parameters
  rc = ExtractArgsCSV(cmdStr$, args, 0, 0)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  select curState
  case STATE_IDLE_nonVSP
    //If advertising or scanning in progress stop them
    #cmpif 0x00000004 : DbgMsg("Going VSP Connectable")
    AdvertsStop()
    ScanningStop()
    //Get default parameters
    if vspAdded == 0 then
      //Do not allow if in current  mux mode
      if AllowPatchToAux() == 0 then
        exitfunc RSP_ERROR_INCORRECT_MODE
      endif
      VspGetDefs()
      //Open the VSP service and variable vspAdded will be updated
      rc = VspOpen()
    endif
    if (vspAdded != 0) && (TrustedDevices()>= vspMinTrusted) then
      //Create the VSP related Advert report and scan report and commit
      VspAdvCreateCommit()
      //Start Advertising
      VspStartAdverts()
      //Change state
      NewState(STATE_IDLE_VSP)
      rc = RSP_OK
    else
      //Change state to idle because we have definitely stopped adverts
      NewState(STATE_IDLE_nonVSP)
      rc = RSP_ERROR_VSP_OPENFAIL
    endif

  case STATE_IDLE_VSP
    //Do nothing as already there anyway
    rc = RSP_OK

  case else
    rc = RSP_ERROR_INCORRECT_MODE

  endselect
endfunc rc

//------------------------------------------------------------------------------
//:/ at+bndt[addr]
//------------------------------------------------------------------------------
function _atPlusBNDT(byref cmdStr$, byref rspBuf$)
  rc = ExtractAddr(cmdStr$) //SArg$[0] is updated with address
  if rc != 0 then
    exitfunc rc
  endif

  dim isTrusted, keyInfo, rollAge, rollCount
  isTrusted =              BleBondingIsTrusted(sArg$[0], BOND_TRUSTED_AS_CENTRAL, keyInfo, rollAge, rollCount)
  isTrusted = isTrusted || BleBondingIsTrusted(sArg$[0], BOND_TRUSTED_AS_PERIPHERAL, keyInfo, rollAge, rollCount)
  if isTrusted then
    if rollAge <= 0 then
      rollAge = 0   //Persistent
    else
      rollAge = 1   //Rolling
    endif
    sprint #tmpVar$, "1, ";rollAge;", ";StrHexize$(sArg$[0])
  else
    tmpVar$ = "0"
  endif
  rspBuf$ = rspBuf$ + rspStart$ + tmpVar$ + rspTerm$
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+bndp[addr]
//------------------------------------------------------------------------------
function _atPlusBNDP(byref cmdStr$, byref rspBuf$)
  rc = ExtractAddr(cmdStr$) //SArg$[0] is updated with address
  if rc != 0 then
    exitfunc rc
  endif
endfunc BleBondingPersistKey(sArg$[0])

//------------------------------------------------------------------------------
//:/ at+bndd[addr]
//------------------------------------------------------------------------------
function _atPlusBNDD(byref cmdStr$, byref rspBuf$)
  rc = ExtractAddr(cmdStr$) //SArg$[0] is updated with address
  if rc != 0 then
    exitfunc rc
  endif

  rc = BleBondingEraseKey(sArg$[0])
  #cmpif 0x00000003 : AssertRC(33070)
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+bndx
//------------------------------------------------------------------------------
function _atPlusBNDX(byref cmdStr$, byref rspBuf$)
  rc = BleBondingEraseAll()
  #cmpif 0x00000003 : AssertRC(33170)
endfunc RSP_OK

//------------------------------------------------------------------------------
// Process ATD command
//:/ATDmacaddress14hexbytes
//:/ == = =
//:/
//:/
//------------------------------------------------------------------------------
function _atD(byref cmdStr$, byref rspBuf$)
  //Do not allow if in current  mux mode
  if AllowPatchToAux() == 0 then
    exitfunc CONN_ERROR_MUXMODE_INCORRECT
  endif

  //Do not allow if we already have a connection
  if connCount > 0 then
    exitfunc CONN_ERROR_TOOMANYCONNECTIONS
  endif

  //Extract address and load nArg[] with connection related parameters
  rc = ConnSetup(cmdStr$)
  if rc!= 0 then
    exitfunc rc
  endif

  //Save which state we got ATD in so we can return to it
  SaveState(oldIdleState)

  //Assume a large default, will be reduced in the connect event from the
  //actual connection event time interval
  vspPumpToutMs = 250

  //Change state
  NewState(STATE_VSP_CONNECTING_OUTGOING)
endfunc CONN_SUSPEND

//------------------------------------------------------------------------------
// Process AT_LCON command
//:/AT_LCONmacaddress14hexbytes
//:/ == = =
//:/
//:/
//------------------------------------------------------------------------------
function _atPlusLCON(byref cmdStr$, byref rspBuf$)
  //Extract address and load nArg[] with connection related parameters
  rc = ConnSetup(cmdStr$)
  if rc!= 0 then
    exitfunc rc
  endif

  if curState != STATE_nonVSP_CONNECTED then
    //Save which state we got AT+LCON in so we can return to it
    SaveState(oldIdleState)
  endif

  //Change state
  NewState(STATE_nonVSP_CONNECTING)
endfunc CONN_SUSPEND

//------------------------------------------------------------------------------
// at+cdtr [0|1]      new BT_UART1_DTR output value
// at+cpwr [0|1]      new LTE_PWR_ON output value
// at+cwku [0|1]      new LTE_WAKE_UP output value
// at+cfsd [0|1]      new LTE_SHUTDN output value
// at+crst [10..500]  Asserts LTE_RESET for the time in milliseconds specified
// at+aslp [0|1]      1 = Allow Sleep, 0 = Disallow Sleep
// at+csts [0|1]      1 = Reset all counts, 0 = no not reset counts
//------------------------------------------------------------------------------
function _atPlusCEL(cmdId, byref cmdStr$, byref rspBuf$)
  dim args, mx

  rc = ExtractArgsCSV(cmdStr$, args, 1, 1)  //Extract argument in sArg$[0]
  if rc!= RSP_OK then
    exitfunc rc
  endif

  //Convert the single parameter
  if cmdId == CMD_CEL_CRST then
    mx = MAX_MODEM_RESET_ASSERT_TIME_MS
  else
    mx = 1
  endif
  rc = SArgConvertToInt(0, 0, 0, mx)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  select cmdId
  case CMD_CEL_ASLP
    if nArg[0] then
      //Allow sleep  -- DTR = 1 WAKE_UP = 0
      nUartDtr = 1
      nWakeup = 0
      #cmpif 0x0000002 :   DbgMsg("Allow Sleep")
    else
      //Disallow sleep  -- DTR = 0 WAKE_UP = 1
      nUartDtr = 0
      nWakeup = 1
      #cmpif 0x0000002 :   DbgMsg("Disallow Sleep")
    endif
    GpioWrite(SIO_LTE_UART1_DTR, nUartDtr)
    GpioWrite(SIO_LTE_WAKE, nWakeup)
    UpdateHlSleepOutput()

  case CMD_CEL_CDTR
    nUartDtr = nArg[0]
    GpioWrite(SIO_LTE_UART1_DTR, nUartDtr)
    #cmpif 0x0000002 :   DbgMsgVal("LTE_UART1_DTR = ", nUartDtr)
    //Update the HL_SLEEP output ( LED4 on devkit)
    UpdateHlSleepOutput()

  case CMD_CEL_CPWR
    nPwrOnN = nArg[0]
    GpioWrite(SIO_LTE_PWR_ON, nPwrOnN)

  case CMD_CEL_CWKU
    nWakeup = nArg[0]
    GpioWrite(SIO_LTE_WAKE, nWakeup)

  case CMD_CEL_CFSD
    nFastShutDnN = nArg[0]
    GpioWrite(SIO_LTE_SHUTDOWN, nFastShutDnN)

  case CMD_CEL_CRST
    select nArg[0]
    case 0
      GpioWrite(SIO_LTE_RESET, 0)
      //Initialise HL State
      NewHlState(HLSTATE_IN_RESET)
    case 1
      GpioWrite(SIO_LTE_RESET, 1)
      if nHlState == HLSTATE_IN_RESET then
        //Initialise HL State
        SetHlStateOnResetRel()
        //Start HL track timer
        TimerStart(TMRNUM_HLSTATE_TRACK, HL_MAX_STARTUP_TIME_MS, 0)
      endif
    case else
      GpioWrite(SIO_LTE_RESET, 0)
      SpinDelay(nArg[0])
      GpioWrite(SIO_LTE_RESET, 1)
      //Initialise HL State
      SetHlStateOnResetRel()
      //Start HL track timer
      TimerStart(TMRNUM_HLSTATE_TRACK, HL_MAX_STARTUP_TIME_MS, 0)
    endselect

  case CMD_CEL_CSTS
    // Send HL78 change counts of VGPIO, GPIO2, GPIO6, UART1DSR in that order
    // separated by comma
    sprint #tmpVar$, nVGpioCnt;", ";nGpio2Cnt;", ";nGpio6Cnt;", ";nUart1DsrCnt
    rspBuf$ = rspBuf$ + rspStart$ + tmpVar$ + rspTerm$
    if nArg[0] then
      nVGpioCnt = 0
      nGpio2Cnt = 0
      nGpio6Cnt = 0
      nUart1DsrCnt = 0
    endif

  case else
  endselect
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+ccms    //get modem state
//------------------------------------------------------------------------------
function _atPlusNoParm(cmdId, byref cmdStr$, byref rspBuf$)
  dim args
  //This command has no parameters
  rc = ExtractArgsCSV(cmdStr$, args, 0, 0)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  select cmdId
  case CMD_NOPARM_CCMS
    sprint #tmpVar$, nHlState>>4
    rspBuf$ = rspBuf$ + rspStart$ + tmpVar$ + rspTerm$

  case CMD_NOPARM_TEMP
    sprint #tmpVar$, sysinfo(2024)
    rspBuf$ = rspBuf$ + rspStart$ + tmpVar$ + rspTerm$

  case else
  endselect
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusCMD_I(cmdId, byref cmdStr$)
  dim args, hConn

  rc = ExtractArgsCSV(cmdStr$, args, 1, 1)  //Extract the connection handle
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert to integer and save in nArg[0]
  rc = SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  if curState != STATE_nonVSP_CONNECTED then
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif

  hConn = connHandles[nArg[0]]
  select cmdId
  // Process AT+LDSC command
  //:/AT+LDSCnn
  //:/ == = =
  case CMD_I_LDSC
    if hConn then
      rc = BleDisconnect(hConn)
      #cmpif 0x00000003 : AssertRC(34740)
    endif

  // Process AT+LMTU command
  //:/AT+LMTUnn
  //:/ == = =
  case CMD_I_LMTU
    if hConn then
      rc = BleGattcAttributeMtuRequest(hConn)
      #cmpif 0x00000001 :  print "\n## BleGattcAttributeMtuRequest() ret:";integer.h' rc
    endif

  // Process AT+LPHY command
  //:/AT+LPHYnn
  //:/ == = =
  case CMD_I_LPHY
    if hConn then
      rc = ChangePhy(hConn)
      #cmpif 0x00000001 :  print "\n## ChangePhy() ret:";integer.h' rc
    endif

  case CMD_I_PAIR
  // Process AT+PAIR command
  //:/AT+PAIRnn
  //:/ == = =
    rc = BlePair(hConn, 1)
    #cmpif 0x00000003 : AssertRC(35000)
    #cmpif 0x00000001 :  print "\n## BlePair() ret:";integer.h' rc

  case CMD_I_LENC
  // Process AT+LENC command
  //:/AT+LENCnn
  //:/ == = =
    rc = BleEncryptConnection(hConn, SRegGet(CfgId_MinEncryptionKeyLen), SRegGet(CfgId_MITMreqForEncryption))
    #cmpif 0x00000003 : AssertRC(35080)

#cmpif 0x00020000 :   case CMD_I_GCTM
#cmpif 0x00020000 :   // Process AT+GCTM command
#cmpif 0x00020000 :   //:/AT+GCTMnn
#cmpif 0x00020000 :   //:/ == = =
#cmpif 0x00020000 :     rc = InitiateTableMap(hConn)
#cmpif 0x00000003 :     AssertRC(35150)

  case else
  endselect
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusPRSP(byref cmdStr$)
  dim args, hConn

  if curState != STATE_nonVSP_CONNECTED then
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif

  rc = ExtractArgsCSV(cmdStr$, args, 2, 3)  //Extract the connection handle & response key
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert to integer and save in nArg[0]
  rc = SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  hConn = connHandles[nArg[0]]
  //Convert the second parameter to lower case
  StrToLower$(sArg$[1])
  if strcmp(sArg$[1], "y") == 0 then
    //Accept pairing
    rc = BleAcceptPairing(hConn, 1)
  elseif strcmp(sArg$[1], "n") == 0 then
    //Reject pairing
    rc = BleAcceptPairing(hConn, 0)
  elseif strlen(sArg$[1]) == 32 then
    //OOB key is provided
    sArg$[1] = StrDehexize$(sArg$[1])
    if strlen(sArg$[1]) == 16 then
      rc = BleSecMngrOOBKey(hConn, sArg$[1])
    else
      rc = RSP_ERROR_INVALID_HEXSTR
    endif
  else
    rc = SArgConvertToInt(1, 0, 0, 999999)
    if rc == RSP_OK then
      rc = BleSecMngrPassKey(hConn, nArg[1])
    endif
  endif
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGCRD_WR(cmdType, byref cmdStr$)
  dim args, hConn

  if curState != STATE_nonVSP_CONNECTED then
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif

  rc = ExtractArgsCSV(cmdStr$, args, 3, 3)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert connhandle to integer and save in nArg[0]
  rc = SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert attrhandle to integer and save in nArg[1]
  rc = SArgConvertToInt(1, 0, 1, 0xFFFE)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  select cmdType
  case 0  // GATTC Read
    //Convert offset to integer and save in nArg[2]
    rc = SArgConvertToInt(2, 0, 0, 511)
    if rc!= RSP_OK then
      exitfunc rc
    endif

  case 1, 2
    tmpVar$ = strdehexize$(sArg$[2])
    if (strlen(tmpVar$) * 2) != strlen(sArg$[2]) then
      exitfunc RSP_ERROR_INVALID_HEXSTR
    endif

  case else
  endselect

  hConn = connHandles[nArg[0]]

  select cmdType
  case 0  // GATTC Read
    rc = BleGattcRead(hConn, nArg[1], nArg[2])

  case 1  //GATTC Write Acked
    rc = BleGattcWrite(hConn, nArg[1], tmpVar$)

  case 2  //GATTC Write NOT Acked
    rc = BleGattcWriteCmd(hConn, nArg[1], tmpVar$)

  case else
  endselect
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGCFA(byref cmdStr$)
  dim args, i, hConn

  if curState != STATE_nonVSP_CONNECTED then
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif

  rc = ExtractArgsCSV(cmdStr$, args, 5, 7)  //Will be 7 if descriptor find
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert connection handle to integer and save in nArg[0]
  rc = SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  for i = 1 to (args + 1)
    //Yes, given we are using MAX_UUID_HANDLES below means that is the highest
    //instance of that object we can look for, but that is not a showstopper restriction in real life
    rc = SArgConvertToInt(i, 0, 0, (MAX_UUID_HANDLES - 1))
    if rc!= RSP_OK then
      exitfunc rc
    endif
  next

  hConn = connHandles[nArg[0]]
  if args == 7 then
    //Find a descriptor
    rc = BleGattcFindDesc(hConn, uuidHandles[nArg[1]], nArg[2], uuidHandles[nArg[3]], nArg[4], uuidHandles[nArg[5]], nArg[6])
  else
    //Find a characteristic
    rc = BleGattcFindChar(hConn, uuidHandles[nArg[1]], nArg[2], uuidHandles[nArg[3]], nArg[4])
  endif
endfunc rc

//------------------------------------------------------------------------------
// AT+UUID n, 16bitUuid, m
// AT+UUID n, 16bitUuid
// AT+UUID n, 32bitHex
//------------------------------------------------------------------------------
function _atPlusUUID(byref cmdStr$, byref rspBuf$)
  dim args, hUuid

  rc = ExtractArgsCSV(cmdStr$, args, 2, 3)  //Extract up to 3 parameters
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert to UUID handle index and save in nArg[0]
  rc = SArgConvertToInt(0, 0, 0, (MAX_UUID_HANDLES - 1))
  if rc!= RSP_OK then
    exitfunc rc
  endif

  if args == 3 then
    //AT+UUID n, 16bituuid, m

    //Convert 16 bit base offset and save in nArg[1]
    rc = SArgConvertToInt(1, 0, 0, 0xFFFF)
    if rc!= RSP_OK then
      exitfunc rc
    endif

    //Convert to UUID handle index and save in nArg[2]
    rc = SArgConvertToInt(2, 0, 0, (MAX_UUID_HANDLES - 1))
    if rc!= RSP_OK then
      exitfunc rc
    endif

    hUuid = BleHandleUuidSibling(uuidHandles[nArg[2]], nArg[1])
  else
    if strlen(sArg$[1]) >= 10 then
      //AT+UUID n, 32bitHex

      //Get the 16 byte UUID
      sArg$[1] = StrDehexize$(sArg$[1])
      if strlen(sArg$[1]) != 16 then
        exitfunc RSP_ERROR_INVALID_HEXSTR
      endif

      hUuid = BleHandleUuid128(sArg$[1])

    else
      //AT+UUID n, 16bitUuid

      //Convert 16 bit base offset and save in nArg[1]
      rc = SArgConvertToInt(1, 0, 0, 0xFFFF)
      if rc!= RSP_OK then
        exitfunc rc
      endif

      hUuid = BleHandleUuid16(nArg[1])

    endif
  endif

  if hUuid == 0 then
    exitfunc RSP_ERROR_INVALID_UUID
  endif

  uuidHandles[nArg[0]] = hUuid

  sprint #tmpVar$, rspStart$ ; integer.h' hUuid ; rspTerm$
  //Append to buffer
  rspBuf$ = rspBuf$ + tmpVar$
endfunc RSP_OK

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusCMD_IS(cmdType, byref cmdStr$)
  dim args, hChar

  rc = ExtractArgsCSV(cmdStr$, args, 2, 2)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert first parm to integer and save in nArg[0]
  rc = SArgConvertToInt(0, 0, 0, MAX_CONNECTIONS)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert data to binary
  tmpVar$ = strdehexize$(sArg$[1])
  if (strlen(tmpVar$) * 2) != strlen(sArg$[1]) then
    exitfunc RSP_ERROR_INVALID_HEXSTR
  endif

  hChar = charHandles[nArg[0]]
  select cmdType
  case CMD_IS_NOTIFY
    if curState != STATE_nonVSP_CONNECTED then
      exitfunc RSP_ERROR_INCORRECT_MODE
    endif
    rc = BleCharValueNotify(hChar, tmpVar$)

  case CMD_IS_INDICATE
    if curState != STATE_nonVSP_CONNECTED then
      exitfunc RSP_ERROR_INCORRECT_MODE
    endif
    rc = BleCharValueIndicate(hChar, tmpVar$)

  case CMD_IS_LOCALWRITE
    rc = BleCharValueWrite(hChar, tmpVar$)

  case else
    rc = RSP_ERROR_UNKNOWN_CMD
  endselect
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGSSB_E(fNew, byref cmdStr$)
  dim args

  if fNew then
    rc = ExtractArgsCSV(cmdStr$, args, 1, 1)  //Extract the UUID handle index
    if rc!= RSP_OK then
      exitfunc rc
    endif
    //Convert to UUID handle index and save in nArg[0]
    rc = SArgConvertToInt(0, 0, 0, (MAX_UUID_HANDLES - 1))
    if rc!= RSP_OK then
      exitfunc rc
    endif

    //A new service is being defined
    if svcHandle then
      //We have not ENDed a service definition yet
      exitfunc RSP_ERROR_SVC_NOTENDED
    endif
    //Always define a primary service
    rc = BleServiceNew(1, uuidHandles[nArg[0]], svcHandle)

  else
    //The end of a service definition
    rc = BleServiceCommit(svcHandle)
    svcHandle = 0

  endif
endfunc rc

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
function _atPlusGSMD(byref cmdStr$)
  dim args, i

  rc = ExtractArgsCSV(cmdStr$, args, 4, 4)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert to metadata handle index and save in nArg[0]
  rc = SArgConvertToInt(0, 1, 1, MAX_METADATA_HANDLES)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert to read & write rights and save in nArg[]
  for i = 1 to 2
    rc = SArgConvertToInt(i, 0, 0, 3)  //4&5 are not allowed.
    if rc!= RSP_OK then
      exitfunc rc
    endif
  next
  //Convert to length and save in nArg[3]
  rc = SArgConvertToInt(3, 1, 1, MAX_ATTRIBUTE_LEN)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  //Set nFlags to 0 -- No capability for authorisation exposed.
  metaHandles[nArg[0]] = BleAttrMetadataEx(nArg[1], nArg[2], nArg[3], 0, rc)
endfunc rc

//------------------------------------------------------------------------------
// AT+GSCB u, pr, m{V}<, m{C}<, m{S}>>  //CharAdd m{XXX} is the metadata index and 0 means not provided.
//------------------------------------------------------------------------------
function _atPlusGSCB(byref cmdStr$)
  dim args, i

  if chrInProg then
    exitfunc RSP_ERROR_CHAR_NOTENDED
  endif

  rc = ExtractArgsCSV(cmdStr$, args, 3, 5)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert to UUID handle index and save in nArg[0]
  rc = SArgConvertToInt(0, 1, 1, (MAX_UUID_HANDLES - 1))
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert to properties and save in nArg[1]
  rc = SArgConvertToInt(1, 1, 1, 63)  //does not allow reliable writes
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Initialise all 3 metadata in nArg[2]..nArg[4] to 0
  nArg[3] = 0 : nArg[4] = 0
  //Convert to read & write rights and save in nArg[]
  args = args - 1
  for i = 2 to args
    rc = SArgConvertToInt(i, 1, 1, MAX_METADATA_HANDLES)
    if rc!= RSP_OK then
      exitfunc rc
    endif
  next
  rc = BleCharNew(nArg[1], uuidHandles[nArg[0]], metaHandles[nArg[2]], metaHandles[nArg[3]], metaHandles[nArg[4]])
  if rc == 0 then
    chrInProg = 1
  endif
endfunc rc

//------------------------------------------------------------------------------
// AT+GSCE hexdata   - returns an index to identify the characteristic
//------------------------------------------------------------------------------
function _atPlusGSCE(byref cmdStr$, byref rspBuf$)
  dim args, charH, nIdx

  if chrInProg == 0 then
    exitfunc RSP_OK
  endif
  if svcHandle == 0 then
    exitfunc RSP_ERROR_SVC_NOTSTARTED
  endif

  rc = ExtractArgsCSV(cmdStr$, args, 1, 1)
  if rc!= RSP_OK then
    exitfunc rc
  endif
  //Convert data to binary
  tmpVar$ = strdehexize$(sArg$[0])
  if (strlen(tmpVar$) * 2) != strlen(sArg$[0]) then
    exitfunc RSP_ERROR_INVALID_HEXSTR
  endif

  rc = BleCharCommit(svcHandle, tmpVar$, charH)
  if rc == 0 then
    chrInProg = 0
    rc = AddCharHandle(charH, nIdx)
    if rc == 0 then
      sprint #tmpVar$, rspStart$ ; nIdx ; rspTerm$
      //Append to buffer
      rspBuf$ = rspBuf$ + tmpVar$
    endif
  endif
endfunc rc

//------------------------------------------------------------------------------
// AT+GSDA u, m, hexdata      //Descriptor Add
//------------------------------------------------------------------------------
//function _atPlusGSDA(byref cmdStr$)
//  dim charH, nIdx
//
//  if chrInProg == 0 then
//    exitfunc RSP_ERROR_CHAR_NOTSTARTED
//  endif
//
//  rc = ExtractArgsCSV(cmdStr$, args, 3, 3)
//  if rc!= RSP_OK then
//    exitfunc rc
//  endif
//  //Convert to UUID handle index and save in nArg[0]
//  rc = SArgConvertToInt(0, 1, 1, (MAX_UUID_HANDLES - 1))
//  if rc!= RSP_OK then
//    exitfunc rc
//  endif
//  //Convert to metadata handle index and save in nArg[1]
//  rc = SArgConvertToInt(1, 1, 1, MAX_METADATA_HANDLES)
//  if rc!= RSP_OK then
//    exitfunc rc
//  endif
//  //Convert data to binary
//  tmpVar$ = strdehexize$(sArg$[2])
//  if (strlen(tmpVar$) * 2) != strlen(sArg$[2]) then
//    exitfunc RSP_ERROR_INVALID_HEXSTR
//  endif
//
//  DO SOMETHING HERE
//
//endfunc rc

//------------------------------------------------------------------------------
// AT% has been encountered
//------------------------------------------------------------------------------
function _atPERCENT(byref cmdStr$, byref rspBuf$)
  //Extract the command letter and process
  select GetAtCmdLetter(cmdStr$)
  case ATCMD_S, (ATCMD_S + 0x20)
    rc = _atsSTR(cmdStr$, rspBuf$)

  case else
    rc = RSP_ERROR_UNKNOWN_CMD

  endselect
endfunc rc

//------------------------------------------------------------------------------
// AT& has been encountered
//------------------------------------------------------------------------------
function _atAMPERSAND(byref cmdStr$, byref rspBuf$)
  //Extract the command letter and process
  select GetAtCmdLetter(cmdStr$)
  case ATCMD_W, (ATCMD_W + 0x20)
    rc = _atampW(cmdStr$, rspBuf$)

  case ATCMD_F, (ATCMD_F + 0x20)
    rc = _atampF(cmdStr$, rspBuf$)

  case else
    rc = RSP_ERROR_UNKNOWN_CMD

  endselect
endfunc rc

//------------------------------------------------------------------------------
// AT! has been encountered
//------------------------------------------------------------------------------
function atEXCLAMATION(byref cmdStr$, byref rspBuf$)
  if GetAtCmdLetter(cmdStr$) == 0 then
    //Cmd string is empty after the ! so valid command, but only valid
    //if not in VSP connection
    if IsVspTunneledToHL() == 0 then
      rc = SendMsgApp(MSGAPP_ENTER_MUXMODE1_HL78, NULL_CTX)
      rc = RSP_SUSPEND
    else
      rc = RSP_ERROR_TUNNELED_TO_VSP
    endif
  else
    //Cmd string is not empty after the ! so unexpected parameter
    rc = RSP_ERROR_TOOMANYARGS
  endif
endfunc rc

//------------------------------------------------------------------------------
//:/ at+nopn max_buf_len <, writable>
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNOPN(byref cmdStr$)
#cmpif 0x00200000 :   dim args
#cmpif 0x00200000 :   sArg$[0] = ""
#cmpif 0x00200000 :   rc = ExtractArgsCSV(cmdStr$, args, 1, 2)
#cmpif 0x00200000 :   if rc!= RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   //Get max_buf_len into nArg[0]
#cmpif 0x00200000 :   rc = SArgConvertToInt(0, NFC_DEFAULT_TAG_SIZE, NFC_MIN_TAG_SIZE, NFC_MAX_TAG_SIZE)
#cmpif 0x00200000 :   if rc!= RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   //Get writable into nArg[1]
#cmpif 0x00200000 :   nArg[1] = 0 //default is not writable
#cmpif 0x00200000 :   if args>1 then
#cmpif 0x00200000 :     rc = SArgConvertToInt(1, 0, 0, 1)
#cmpif 0x00200000 :     if rc!= RSP_OK then
#cmpif 0x00200000 :       exitfunc rc
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   //Open NFC and allocate memory for the ndef message
#cmpif 0x00200000 :   rc = NfcOpen(0, "\00", nfcHandle)
#cmpif 0x00200000 :   if rc == 0 then
#cmpif 0x00200000 :     rc = NfcNdefMsgNew(nArg[0], ndefHandle)
#cmpif 0x00200000 :     if rc!= 0 then
#cmpif 0x00200000 :       NfcClose(nfcHandle)
#cmpif 0x00200000 :       nfcHandle = INVALID_NFC_HANDLE
#cmpif 0x00200000 :       ndefHandle = INVALID_NDEF_HANDLE
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+ncls
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNCLS()
#cmpif 0x00200000 :   if nfcHandle!= INVALID_NFC_HANDLE then
#cmpif 0x00200000 :     if ndefHandle!= INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :       //Release the ndef message buffer
#cmpif 0x00200000 :       rc = NfcNdefMsgDelete(ndefHandle)
#cmpif 0x00200000 :       ndefHandle = INVALID_NDEF_HANDLE
#cmpif 0x00200000 :       //Close the NFC
#cmpif 0x00200000 :       NfcClose(nfcHandle)
#cmpif 0x00200000 :       nfcHandle = INVALID_NFC_HANDLE
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc 0  //  rc = 0

//------------------------------------------------------------------------------
//:/ at+nrst
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNRST()
#cmpif 0x00200000 :   rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if nfcHandle!= INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     if ndefHandle!= INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :       rc = NfcNdefMsgReset(ndefHandle)
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+nrat "lang", "message"
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNRAT(byref cmdStr$)
#cmpif 0x00200000 :   dim args, id$, type$, lang$
#cmpif 0x00200000 :   sArg$[0] = ""
#cmpif 0x00200000 :   rc = ExtractArgsCSV(cmdStr$, args, 2, 2)
#cmpif 0x00200000 :   if rc!= RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if ndefHandle!= INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     //Add a NDEF Record of type "T" and message in language code provided
#cmpif 0x00200000 :     lang$ = "\00"+sArg$[0]
#cmpif 0x00200000 :     rc = strsetchr(lang$, strlen(lang$) - 1, 0)
#cmpif 0x00200000 :     //AssertRC(40870)
#cmpif 0x00200000 :     id$ = ""
#cmpif 0x00200000 :     type$ = "T"
#cmpif 0x00200000 :     StrDeEscape(sArg$[1])
#cmpif 0x00200000 :     rc = NfcNdefRecAddGeneric(ndefHandle, NFC_TNF_WELL_KNOWN, type$, id$, lang$, INVALID_NDEF_HANDLE, sArg$[1])
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+nrag tnf, "type", "id", "val0"
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNRAG(byref cmdStr$)
#cmpif 0x00200000 :   dim args
#cmpif 0x00200000 :   sArg$[0] = ""
#cmpif 0x00200000 :   rc = ExtractArgsCSV(cmdStr$, args, 4, 4)
#cmpif 0x00200000 :   if rc!= RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   //Get tnf into nArg[0]
#cmpif 0x00200000 :   rc = SArgConvertToInt(0, NFC_TNF_UNKNOWN_TYPE, NFC_TNF_EMPTY, NFC_TNF_RESERVED)
#cmpif 0x00200000 :   if rc!= RSP_OK then
#cmpif 0x00200000 :     exitfunc rc
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 :
#cmpif 0x00200000 :   rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if ndefHandle!= INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     //Add a NDEF Record
#cmpif 0x00200000 :     StrDeEscape(sArg$[1])
#cmpif 0x00200000 :     StrDeEscape(sArg$[2])
#cmpif 0x00200000 :     StrDeEscape(sArg$[3])
#cmpif 0x00200000 :     tmpVar$ = ""
#cmpif 0x00200000 :     rc = NfcNdefRecAddGeneric(ndefHandle, nArg[0], sArg$[1], sArg$[2], sArg$[3], INVALID_NDEF_HANDLE, tmpVar$)
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+ncmt
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNCMT()
#cmpif 0x00200000 :   dim records, memTotal, memUsed
#cmpif 0x00200000 :   rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if nfcHandle!= INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     rc = NfcNdefMsgGetInfo(ndefHandle, records, memTotal, memUsed)
#cmpif 0x00200000 :     if rc == 0 then
#cmpif 0x00200000 :       if records>0 then
#cmpif 0x00200000 :         rc = NfcNdefMsgCommit(nfcHandle, ndefHandle)
#cmpif 0x00200000 :       else
#cmpif 0x00200000 :         rc = RSP_ERROR_NFC_NDEF_EMPTY
#cmpif 0x00200000 :       endif
#cmpif 0x00200000 :     endif
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+nsen
//:/ at+nsds
//------------------------------------------------------------------------------
#cmpif 0x00200000 : function _atPlusNS_EN_DS( onOff )
#cmpif 0x00200000 :   rc = RSP_ERROR_NFC_NOT_OPEN
#cmpif 0x00200000 :   if nfcHandle!= INVALID_NDEF_HANDLE then
#cmpif 0x00200000 :     rc = NfcFieldSense(nfcHandle, onOff)
#cmpif 0x00200000 :   endif
#cmpif 0x00200000 : endfunc rc

//------------------------------------------------------------------------------
//:/ at+acmt    //Commit NonVspo advert & scan reports if not in VSP  mode
//------------------------------------------------------------------------------
function _atPlusACMT()
  if (curState == STATE_IDLE_nonVSP)||(curState == STATE_nonVSP_CONNECTED) then
    //Only allow reports to be commited if in non-VSP idle mode or non-vsp connected
    IdleAdvCommit()
  else
    exitfunc RSP_ERROR_INCORRECT_MODE
  endif
endfunc 0

//------------------------------------------------------------------------------
//:/ at+aara tag, "data"  //Append AD to NonVsp Advert report
//:/ at+asra tag, "data"  //Append AD to NonVsp Scan report
//------------------------------------------------------------------------------
function _atPlusAxRA(cmdStr$, rpt$)
  dim args
  rc = ExtractArgsCSV(cmdStr$, args, 2, 2)
  if rc == 0 then
    //Convert the tag to an integer
    rc = SArgConvertToInt(0, -1, 0, 255)  //-1 will result in an error
    if rc!= RSP_OK then
      exitfunc rc
    endif
    //De-escape the data
    StrDeEscape(sArg$[1])
    //Finally append to the report
    rc = BleAdvRptAppendAD(rpt$, nArg[0], sArg$[1])
  endif
endfunc rc

//------------------------------------------------------------------------------
//:/ at+auxc baud, flow  //change baudrate and flow control for aux port connected to modem
//:/ at+urtc baud, flow  //change baudrate and flow control for main port connected to host
//------------------------------------------------------------------------------
function _atPlusAUXURTC(cmdStr$, prt)  //prt = 0 for main, 1 for aux
  dim args
  rc = ExtractArgsCSV(cmdStr$, args, 1, 2)
  if rc == 0 then
    //Convert the baudrate to an integer
    rc = SArgConvertToInt(0, -1, 1200, 1000000)  //-1 will result in an error
    if rc!= RSP_OK then
      exitfunc rc
    endif
    //Convert the flow to an integer and will default to 1 if not supplied
    rc = SArgConvertToInt(1, 1, 0, 1) //defaults to enabled flow
    if rc!= RSP_OK then
      exitfunc rc
    endif
    //Finally reconfig the port
  endif
  if prt == 1 then
    //Change baudrate of aux port
    auxBaud = nArg[0]
    auxFlow = nArg[1]
    OpenAuxPort()
    #cmpif 0x00000004 : DbgMsgVal("Aux Baud = ", auxBaud)
    #cmpif 0x00000004 : DbgMsgVal("Aux Flow = ", auxFlow)
  elseif prt == 0 then
    //Change baudrate of main port
    if muxMode == MULTIPLEXER_MODE_GPIO then
      urtBaud = nArg[0]
      urtFlow = nArg[1]
      UARTClose()
      UartReOpen()
      SpinDelay(UART_POST_URTC_DELAY_MS)
      #cmpif 0x00000004 : DbgMsgVal("Urt Baud = ", urtBaud)
      #cmpif 0x00000004 : DbgMsgVal("Urt Flow = ", urtFlow)
    else
      exitfunc RSP_ERROR_INCORRECT_MODE
    endif
  else
    exitfunc RSP_ERROR_VALUE_NOT_VALID
  endif
endfunc RSP_OK

//------------------------------------------------------------------------------
//:/ at+arst <conn>   //Non Vsp Advert reports reset ( conn == 0 or 1) default = 1
//:/ at+sfmt <fmt>    //scan advert report format type, default fmt = 0
//------------------------------------------------------------------------------
function _atPlusM0O1(byref cmdStr$, cmdId, defval, mn, mx)
  dim args
  rc = ExtractArgsCSV(cmdStr$, args, 0, 1)
  if rc!= RSP_OK then
    exitfunc rc
  endif

  //Extract optional parameter
  if args == 1 then
    rc = SArgConvertToInt(0, defval, mn, mx)
    if rc!= RSP_OK then
      exitfunc rc
    endif
  else
    nArg[0] = defval
  endif

  select cmdId
  case 0 //Arst
    GenAdvCreateMinimal(idleAdvRpt$, idleScnRpt$)
    if nArg[0] == 0 then
      //Not connectable advert so we can remove all AD elements from the ADV report
      idleAdvRpt$ = idleScnRpt$
    endif

  case 1 //Sfmt
    scnFmt = nArg[0]

  case else
  endselect
endfunc rc

//------------------------------------------------------------------------------
// AT+ has been encountered
//------------------------------------------------------------------------------
function _atPLUS(byref cmdStr$, byref rspBuf$)
  dim tmp$

  //Extract the first 4 characters
  tmp$ = StrSplitLeft$(cmdStr$, 4)
  //Convert all data to lower case
  StrToLower$(tmp$)
  //Check what command it is
  if strcmp(tmp$, "sior") == 0 then
    rc = _atPlusSIO(0, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "siow") == 0 then
    rc = _atPlusSIO(1, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "sioc") == 0 then
    rc = _atPlusSIO(2, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "aslp") == 0 then
    rc = _atPlusCEL(CMD_CEL_ASLP, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "cdtr") == 0 then
    rc = _atPlusCEL(CMD_CEL_CDTR, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "cpwr") == 0 then
    rc = _atPlusCEL(CMD_CEL_CPWR, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "cwku") == 0 then
    rc = _atPlusCEL(CMD_CEL_CWKU, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "cfsd") == 0 then
    rc = _atPlusCEL(CMD_CEL_CFSD, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "crst") == 0 then
    rc = _atPlusCEL(CMD_CEL_CRST, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "csts") == 0 then
    rc = _atPlusCEL(CMD_CEL_CSTS, cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "ccms") == 0 then
    rc = _atPlusNoParm(CMD_NOPARM_CCMS , cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "temp") == 0 then
    rc = _atPlusNoParm(CMD_NOPARM_TEMP , cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "lscn") == 0 then
    rc = _atPlusLSCN(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "lvsp") == 0 then
    rc = _atPlusLVSP(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "ladv") == 0 then
    rc = _atPlusLADV(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "bndt") == 0 then
    rc = _atPlusBNDT(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "bndp") == 0 then
    rc = _atPlusBNDP(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "bndd") == 0 then
    rc = _atPlusBNDD(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "bndx") == 0 then
    rc = _atPlusBNDX(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "lcon") == 0 then
    rc = _atPlusLCON(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "ldsc") == 0 then
    rc = _atPlusCMD_I(CMD_I_LDSC, cmdStr$)

  elseif strcmp(tmp$, "lmtu") == 0 then
    rc = _atPlusCMD_I(CMD_I_LMTU, cmdStr$)

  elseif strcmp(tmp$, "lphy") == 0 then
    rc = _atPlusCMD_I(CMD_I_LPHY, cmdStr$)

  elseif strcmp(tmp$, "pair") == 0 then
    rc = _atPlusCMD_I(CMD_I_PAIR, cmdStr$)

  elseif strcmp(tmp$, "lenc") == 0 then
    rc = _atPlusCMD_I(CMD_I_LENC, cmdStr$)

  elseif strcmp(tmp$, "prsp") == 0 then
    rc = _atPlusPRSP(cmdStr$)

  elseif strcmp(tmp$, "gcrd") == 0 then
    rc = _atPlusGCRD_WR(0, cmdStr$)

  elseif strcmp(tmp$, "gcwa") == 0 then    //Write acked
    rc = _atPlusGCRD_WR(1, cmdStr$)

  elseif strcmp(tmp$, "gcwc") == 0 then    //Write cmd (not acked)
    rc = _atPlusGCRD_WR(2, cmdStr$)

  elseif strcmp(tmp$, "gcfa") == 0 then    //Find attribute of characteristic value or descriptor
    rc = _atPlusGCFA(cmdStr$)

  elseif strcmp(tmp$, "uuid") == 0 then
    rc = _atPlusUUID(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "gsno") == 0 then
    rc = _atPlusCMD_IS(CMD_IS_NOTIFY, cmdStr$)

  elseif strcmp(tmp$, "gsic") == 0 then
    rc = _atPlusCMD_IS(CMD_IS_INDICATE, cmdStr$)

  elseif strcmp(tmp$, "gssb") == 0 then
    rc = _atPlusGSSB_E(1, cmdStr$)

  elseif strcmp(tmp$, "gsse") == 0 then
    rc = _atPlusGSSB_E(0, cmdStr$)

  elseif strcmp(tmp$, "gsmd") == 0 then
    rc = _atPlusGSMD(cmdStr$)

  elseif strcmp(tmp$, "gscb") == 0 then
    rc = _atPlusGSCB(cmdStr$)

  elseif strcmp(tmp$, "gsce") == 0 then
    rc = _atPlusGSCE(cmdStr$, rspBuf$)

  elseif strcmp(tmp$, "gswc") == 0 then
    rc = _atPlusCMD_IS(CMD_IS_LOCALWRITE, cmdStr$)

  elseif strcmp(tmp$, "arst") == 0 then
    rc = _atPlusM0O1(cmdStr$, 0, 1, 0, 1)

  elseif strcmp(tmp$, "acmt") == 0 then
    rc = _atPlusACMT()

  elseif strcmp(tmp$, "aara") == 0 then
    rc = _atPlusAxRA(cmdStr$, idleAdvRpt$)

  elseif strcmp(tmp$, "asra") == 0 then
    rc = _atPlusAxRA(cmdStr$, idleScnRpt$)

  elseif strcmp(tmp$, "sfmt") == 0 then
    rc = _atPlusM0O1(cmdStr$, 1, 0, 0, 1)

  elseif strcmp(tmp$, "auxc") == 0 then
    rc = _atPlusAUXURTC(cmdStr$, 1)

  elseif strcmp(tmp$, "urtc") == 0 then
    rc = _atPlusAUXURTC(cmdStr$, 0)

//  --------------------------------------------------
// Following only to be added when custom descriptor requirement
// asked for.
//  --------------------------------------------------
//  elseif strcmp(tmp$, "gsda") == 0 then
//    rc = _atPlusGSDA(cmdStr$)
//  --------------------------------------------------

  //Optional Tablemap command
#cmpif 0x00020000 :   elseif strcmp(tmp$, "gctm") == 0 then  //tablemap
#cmpif 0x00020000 :     rc = _atPlusCMD_I(CMD_I_GCTM, cmdStr$)

  //Optional NFC related commands
#cmpif 0x00200000 :   elseif strcmp(tmp$, "nopn") == 0 then
#cmpif 0x00200000 :     rc = _atPlusNOPN(cmdStr$)
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$, "ncls") == 0 then
#cmpif 0x00200000 :     rc = _atPlusNCLS()
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$, "nrst") == 0 then
#cmpif 0x00200000 :     rc = _atPlusNRST()
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$, "nrat") == 0 then
#cmpif 0x00200000 :     rc = _atPlusNRAT(cmdStr$)
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$, "nrag") == 0 then
#cmpif 0x00200000 :     rc = _atPlusNRAG(cmdStr$)
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$, "ncmt") == 0 then
#cmpif 0x00200000 :     rc = _atPlusNCMT()
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$, "nsen") == 0 then
#cmpif 0x00200000 :     rc = _atPlusNS_EN_DS(1)
#cmpif 0x00200000 :
#cmpif 0x00200000 :   elseif strcmp(tmp$, "nsds") == 0 then
#cmpif 0x00200000 :     rc = _atPlusNS_EN_DS(0)

  elseif strcmp(tmp$, "exit") == 0 then
    OnAppExit(1)
    stop

  elseif strcmp(tmp$, "fup\r") == 0 then
    //Enter bootloader mode
    reset(2)

  else
    //Not a known 'at+' command
    rc = RSP_ERROR_UNKNOWN_CMD
  endif
endfunc rc

//------------------------------------------------------------------------------
// Function for parsing commands when in application command mode and cmdStr$
// is at least 3 characters
//------------------------------------------------------------------------------
sub ParseAtCommand(byref cmdStr$, byref rspBuf$)
  //Extract the first 2-characters
  parseTmp$ = StrSplitLeft$(cmdStr$, 2)
  nPrefix = TableLookup(cmdPrefix$, parseTmp$)
  //Check if it is a valid prefix
  if nPrefix<0 then
    //Not a valid prefix command
    AppendRspEnd(RSP_ERROR_SYNTAX_ERROR, rspBuf$)
    exitsub
  endif

  //If this is lowercase 'at' (prefix id == 0) then send it to HL when in intelligent mode
  if (muxMode == MULTIPLEXER_MODE_INTELLIGENT) then
    //In intelligent mode
    if nPrefix == 0 then
      if curState == STATE_VSP_PATCH_CONNECTED then
        AppendRspEnd(RSP_ERROR_TUNNELED_TO_VSP, rspBuf$)
        exitsub
      else
        //Send everything to HL
        AuxSendDataEx(parseTmp$)
        AuxSendDataEx(cmdStr$)
        //And suspend the parser
        AppendRspEnd(RSP_SUSPEND, rspBuf$)
        //Change handlers and state
        DisableUartAuxEvents()
        rc = SendMsgApp(MSGAPP_ENTER_MUXMODE2_HL78_BUSY, NULL_CTX)
        exitsub
      endif
    endif
    //All other prefixes are allowed
  #cmpif 0x04000000 : else
    #cmpif 0x04000000 : //Not in intelligent mode, so only prefix 0 to 3 inclusive are allowed
    #cmpif 0x04000000 : //because cmdPrefix$ has been initialised that way.
    #cmpif 0x04000000 : if nPrefix>= 0x04 then
    #cmpif 0x04000000 :   //Not a valid prefix command
    #cmpif 0x04000000 :   AppendRspEnd(RSP_ERROR_SYNTAX_ERROR, rspBuf$)
    #cmpif 0x04000000 :   exitsub
    #cmpif 0x04000000 : endif
  endif

  //Extract the command letter and process
  select GetAtCmdLetter(cmdStr$)
  case ATCMD_EMPTY
    rc = RSP_OK

  case ATCMD_I, (ATCMD_I + 0x20)
    rc = _ati(cmdStr$, rspBuf$)

  case ATCMD_S, (ATCMD_S + 0x20)
    rc = _ats(cmdStr$, rspBuf$)

  case ATCMD_D, (ATCMD_D + 0x20)
    rc = _atD(cmdStr$, rspBuf$)
    AppendConnRspEnd(rc, rspBuf$)
    exitsub //Because we don't want to hit the AppendRspEnd() at the end of this routine

  case ATCMD_H, (ATCMD_H + 0x20)
    if connHandles[HCONN_VSP] != INVALID_CONN_HANDLE then
      rc = BleDisconnect(connHandles[HCONN_VSP])
      #cmpif 0x00000003 : AssertRC(44910)
      //Change state
      NewState(STATE_VSP_DISCONNECTING)
    else
      rc = RSP_OK
    endif

  case ATCMD_Z, (ATCMD_Z + 0x20)
    reset(0)

  case ATCMD_PERCENT
    rc = _atPERCENT(cmdStr$, rspBuf$)

  case ATCMD_AMPERSAND
    rc = _atAMPERSAND(cmdStr$, rspBuf$)

  case ATCMD_PLUS
    rc = _atPLUS(cmdStr$, rspBuf$)

  case ATCMD_EXCLAMATION
    if muxMode == MULTIPLEXER_MODE_NONGPIO then
      rc = atEXCLAMATION(cmdStr$, rspBuf$)
    else
      rc = RSP_ERROR_INCORRECT_MODE
    endif

  case else
    if muxMode == MULTIPLEXER_MODE_INTELLIGENT then
      //
    else
      rc = RSP_ERROR_UNKNOWN_CMD
    endif
  endselect

  // Add an OK or ERROR to the response
  AppendRspEnd(rc, rspBuf$)
endsub

//------------------------------------------------------------------------------
// Routine to service command mode, if it returns 0, then it implies exit the application
//------------------------------------------------------------------------------
sub ProcessCommands(byref ORIGRecBuf$, byref RSPSndBuf$)
  dim termPos, cmdStr$

  //Find position of the first command terminator in the string
  termPos = StrPos(ORIGRecBuf$, cmdTerm$, 0)
  while (atParse)&&(termPos >= 0)
    if (termPos == 0) then
      //Empty string so just send OK
      AppendRspEnd(RSP_OK, RSPSndBuf$)
      cmdStr$ = StrSplitLeft$(ORIGRecBuf$, 1)
    else
      //Non empty string
      termPos = termPos + 1
      cmdStr$ = StrSplitLeft$(ORIGRecBuf$, termPos)

      //Parse and run AT command
      ParseAtCommand(cmdStr$, RSPSndBuf$)
    endif
    //Send out data waiting in buffer
    UartSendFrom840()
    //Find position of the first command terminator in the string
    termPos = StrPos(ORIGRecBuf$, cmdTerm$, 0)
  endwhile
endsub

//******************************************************************************
// Handlers
//******************************************************************************

//==============================================================================
// In Command mode and data has arrived from the UART
//==============================================================================
function HndlrUartCmd()
  //Data received from UART
  tmpVar = UARTReadN(urtRxBuf$, MaxCmdStringSize)
  ProcessCommands(urtRxBuf$, urtTxCache$)
endfunc 1

//==============================================================================
// In Command mode and data has arrived from the UART and the device is in the
// intelligent mux mode.
//==============================================================================
function HndlrUartCmdMode2()
  //Data received from UART
  tmpVar = UARTReadN(urtRxBuf$, MaxCmdStringSize)
  ProcessCommands(urtRxBuf$, urtTxCache$)
endfunc 1

//==============================================================================
// In Command mode and UART Tx buffer is empty
//==============================================================================
function HndlrUartRspPump()
  UartSendFrom840()
endfunc 1

//==============================================================================
// Called when scanning has timed out
//==============================================================================
function HndlrScanTimeout() as integer
  #cmpif 0x00000004 : DbgMsg("Scan Timeout")

  if curState == STATE_SCAN_VSP then
    rc = BleScanAbort()

    IdleReturnAction()

    //Send an OK response
    AppendRspEnd(RSP_OK, urtTxCache$)
    //Send out data waiting in buffer
    UartSendFrom840()
    //Also trigger a reprocessing of the UART buffer just in case
    rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
  else
    //Send a 'scanend' response
    SendScanEnd(urtTxCache$)
  endif
endfunc 1

//==============================================================================
// This handler is called when a connection attempt has timeout
//==============================================================================
function HndlrConnTout()
  #cmpif 0x00000004 : DbgMsg("Connect Timeout")
  select curState
  case STATE_VSP_CONNECTING_OUTGOING
    VspNoCarrierRet(CONN_ERROR_TIMEOUT)

  case STATE_nonVSP_CONNECTING
    if connCount<= 0 then
      //First outgoing nonVSP connection
      NonVspDisconRet(CONN_ERROR_TIMEOUT, 0)  //will take us back to the idle state
    else
      //Multiple nonVSP connections
      //send an DISCON response
      SendNonVspDiscon(CONN_ERROR_TIMEOUT, 0, urtTxCache$)
      //Change state
      NewState(STATE_nonVSP_CONNECTED)
      //Also trigger a reprocessing of the UART buffer just in case
      rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
    endif

  case else
  endselect
endfunc 1

//==============================================================================
// This handler is called when there at least one scan response waiting to be read
dim _display, _adType  //To only be used by the following functions
//==============================================================================
function HndlrAdvReport()
  //Read all cached advert reports
  rc = BleScanGetAdvReportEx(_adType, periphAddr$, advData$, nDiscarded, nRssi, tmpVar)
  while (rc == 0)
    #cmpif 0x00000400 : print dbgStart$;"Adv = ";strhexize$(advData$)
    _display = 0
    if nRssi > scnRssi then
      if scnPatternLen>0 then
        if strpos(advData$, scnPattern$, 0) >= 0 then
          //RSSI is above threshold and pattern found
          _display = 1
        endif
      else
        //RSSI is above threshold and no pattern specified
        _display = 1
      endif
    endif
    if _display then
      if muxToHL == 0 then
        UartReOpen()
        print rspStart$;advPrefix$;_adType;" ";StrHexize$(periphAddr$);" ";nRssi
        select scnFmt
        case 1
          print " \22"; StrHexize$(advData$);"\22";rspTerm$

        case else
          rc = BleGetADBytag(advData$, 0x09, nme$)
          print " \22"; nme$ ; "\22";rspTerm$
        endselect
      endif
    endif
    rc = BleScanGetAdvReport(periphAddr$, advData$, nDiscarded, nRssi)
  endwhile
endfunc 1

//==============================================================================
//Disconnect
//==============================================================================
function HndlrDisCon(hndl as integer, rsn as integer)
  #cmpif 0x00000004 : DbgMsg("Disconnect")

  select curState
  case STATE_VSP_DISCONNECTING, STATE_VSP_PAIRING, STATE_VSP_PATCH_CONNECTED
    //Some other error while writing to a cccd
    if vspDisconSts<= 0 then
      //Assume a normal disconnection has happened
      vspDisconSts = CONN_ERROR_USER_DISCON
    endif
    VspNoCarrierRet(vspDisconSts)
    connHandles[HCONN_VSP] = INVALID_CONN_HANDLE

  case STATE_nonVSP_CONNECTING, STATE_nonVSP_CONNECTED
    dim nodeIdx : nodeIdx = GetIdxFromHConn(hndl)
    if nodeIdx == 0 then
      //Ignore this because we were not track that connection
    else
      if connCount<= 1 then  //Comparing against 1 because it decremented at the end of this routine
        //first outgoing nonVSP connection
        NonVspDisconRet(rsn, nodeIdx)  //will take us back to the idle state
      else
        //Multiple nonVSP connections
        //send an DISCON response
        SendNonVspDiscon(rsn, nodeIdx, urtTxCache$)
        //Also trigger a reprocessing of the UART buffer just in case
        rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)
      endif
      connHandles[nodeIdx] = INVALID_CONN_HANDLE
    endif

  case STATE_VSP_IGNORED
    connHandles[HCONN_VSP] = INVALID_CONN_HANDLE
    //Change state
    NewState(STATE_IDLE_VSP)

  case else
    VspNoCarrierRet(rsn)
    connHandles[HCONN_VSP] = INVALID_CONN_HANDLE
  endselect

  if connCount>0 then
    //Decrement the connection count
    connCount = connCount - 1
  endif
endfunc 1

//==============================================================================
//CCCD Descriptor found via BleGattcFindDesc()
//==============================================================================
function HndlrFindDesc(hConn, hAttr)
  //#cmpif 0x00000004 : DbgMsgVal("EvFindDesc hAttr = ", hAttr)

  select curState
  case STATE_VSP_GET_HANDLES
    SvcFindCharDescEv(hConn, hAttr)

  case STATE_nonVSP_CONNECTED
    //Get connection index from conn handle
    tmpVar = GetIdxFromHConn(hConn)
    sprint #tmpVar$, rspStart$;"FD:";tmpVar;", ";hAttr;rspTerm$
    UartSendFrom840Ex(tmpVar$)

  case else
  endselect
endfunc 1

//==============================================================================
//Characteristic found via BleGattcFindChar()
//==============================================================================
function HndlrFindChar(hConn, cProp, hAttr, hIncSvcUuid)
  //#cmpif 0x00000004 : DbgMsgVal("EvFindChar hAttr = ", hAttr)

  select curState
  case STATE_VSP_GET_HANDLES
    SvcFindCharDescEv(hConn, hAttr)

  case STATE_nonVSP_CONNECTED
    //Get connection index from conn handle
    tmpVar = GetIdxFromHConn(hConn)
    sprint #tmpVar$, rspStart$;"FC:";tmpVar;", ";hAttr;", ";cProp;rspTerm$
    UartSendFrom840Ex(tmpVar$)

  case else
  endselect
endfunc 1

//==============================================================================
//AUX data received in VSP fast connected state (as master)
//==============================================================================
function HndlrBridgeOutPatch()
  //Read data that has arrived via the Aux
  if (vspAllowTx == 1) then
    do
      tmpVar = AuxReadN(auxRxPatch$, vspAttrMaxLen)
      if tmpVar > 0 then
        rc = BleGattcWriteCmd(connHandles[HCONN_VSP], hVspAttr[VSP_ATTR_INDEX_RX], auxRxPatch$)

        select rc

        //0000 = UWRESULTCODE_SUCCESS
        case 0
          StrShiftLeft(auxRxPatch$, tmpVar)
          #cmpif 0x00000040 : vtxcnt = vtxcnt+tmpVar

        //6804 = UWRESULTCODE_BLE_NO_TX_BUFFERS
        //6213 = UWRESULTCODE_BLE_RESOURCES - too many writes without responses queued
        //          Wait for a BLE_GATTC_EVT_WRITE_CMD_TX_COMPLETE event and retry which is EVNOTIFYBUF in sb
        case 0x6804, 0x6213
          TimerStart(TMRNUM_DATA_PUMP, vspPumpToutMs, 0)
          exitfunc 1

        //620C = UWRESULTCODE_BLE_DATA_SIZE
        case 0x620C
          tmpVar$ = StrSplitLeft$(auxRxPatch$, vspAttrMaxLen)
          rc = BleGattcWriteCmd(connHandles[HCONN_VSP], hVspAttr[VSP_ATTR_INDEX_RX], tmpVar$)
          if rc!= 0 then
            //Did not manage to sent it, so put it back in the original buffer (at the beginning)
            auxRxPatch$ = tmpVar$+auxRxPatch$
            if (rc == 0x6804)||(rc == 0x6213) then //BLE_NO_TX_BUFFERS or BLE_RESOURCES
              TimerStart(TMRNUM_DATA_PUMP, vspPumpToutMs, 0)
              exitfunc 1
            endif
            #cmpif 0x00000040 : else
            #cmpif 0x00000040 :   vtxcnt = vtxcnt+tmpVar
          endif

        //Some other error, so just exit
        case else
          exitfunc 1

        endselect
      endif
    dowhile tmpVar
  endif
endfunc 1

//==============================================================================
//This timer was started when notify buffers ran out while calling WriteCmd
//==============================================================================
function HndlrTmrVspPump()
  select curState
  case STATE_VSP_PATCH_CONNECTED
    rc = HndlrBridgeOutPatch()

  case else
  endselect
endfunc 1

//==============================================================================
//A write to an attribute has been acked/nacked
//==============================================================================
function HandlerAttrWrite(hConn, hAttr, xSts)
  //#cmpif 0x00000004 : print dbgStart$;"EvAttrWrite hAttr = ";hAttr;" sts = ";xSts

  select curState
  case STATE_VSP_WRITE_CCCDS
    //Save status for later use
    vspDisconSts = nSts
    //Check status
    if xSts == 0 then
      //#cmpif 0x00000004 : DbgMsg("EvAttrWrite OK")
      //a cccd was successfuly written, so check for next
      vspFindIndex = vspFindIndex + 1
      if vspFindIndex>= VSP_ATTR_MAX_INDEXES then
        //All cccd's written
        vspIsOutGoing = TRUE
        VspEnterConnState(MSGAPP_ENTER_VSPOUT_CONN_STATE)
      else
        //There could be more cccd's to enable
        rc = CccdsEnable()
        if rc == 0 then
          //There were no more cccd's to enable
          vspIsOutGoing = TRUE
          VspEnterConnState(MSGAPP_ENTER_VSPOUT_CONN_STATE)
        else
          //A write has been sent to a cccd, remain in this state
          //NOTHING TO DO
        endif
      endif
    elseif (Is_Encr_Required(xSts) != 0) && (pairIoCapCache == 0) then
      #cmpif 0x00000004 : DbgMsg("EvAttrWrite Encr Req ** Start PAIRING")
      //The link requires encryption, and configured for just works
      rc = BlePair(hConn, 1)
      #cmpif 0x00000003 : AssertRC(48630)
      //Change state
      NewState(STATE_VSP_PAIRING)
    else
      #cmpif 0x00000004 : DbgMsgVal("EvAttrWrite other err", xSts)
      //Some other error, so just drop the connection
      vspDisconSts = CONN_ERROR_AUTHLINK_REQUIRED
      rc = BleDisconnect(hConn)
      //Change state
      NewState(STATE_VSP_DISCONNECTING)
    endif

  case STATE_VSP_PATCH_CONNECTED
    //And immediately send more data if we can
    rc = HndlrBridgeOutPatch()

  case STATE_nonVSP_CONNECTED
    dim nIdx
    //Get connection index from conn handle
    nIdx = GetIdxFromHConn(hConn)
    sprint #tmpVar$, rspStart$;"AW:";nIdx;", ";xSts;rspTerm$
    UartSendFrom840Ex(tmpVar$)

  case else
  endselect
endfunc 1

//==============================================================================
//==============================================================================
function HndlrAttrRead(hConn, hAttr, xSts) as integer
  dim a$, ofst, nIdx
  //Get connection index from conn handle
  nIdx = GetIdxFromHConn(hConn)
  if xSts == 0 then
    //We have a successful read
    rc = BleGattcReadData(hConn, hAttr, ofst, a$)
    if rc == 0 then
      sprint #tmpVar$, rspStart$;"AR:";nIdx;", ";ofst;", ";StrHexize$(a$);rspTerm$
    else
      sprint #tmpVar$, rspStart$;"AB:";nIdx;", ";integer.h' rc;rspTerm$
    endif
  else
    //Failed to read
    sprint #tmpVar$, rspStart$;"AS:";nIdx;", ";xSts;rspTerm$
  endif
  UartSendFrom840Ex(tmpVar$)
endfunc 1

//==============================================================================
// Called when UART Tx buffer is empty in VSP fast mode
//==============================================================================
function HndlrAuxTxEmptyOut()
  VspMasterRtsSend(1)
  AuxSendData()
endfunc 1

//==============================================================================
//Vsp (air-side) data received in VSP fast connected state
//==============================================================================
function HndlrNotifyVspOut()
  dim hConn, hAttr, aData$, discard, wrLen
  rc = BleGattcNotifyRead(hConn, hAttr, aData$, discard)
  while (rc == 0)
    if (hAttr == hVspAttr[VSP_ATTR_INDEX_TX]) then
      //Data has arrived
      AuxSendDataEx(aData$)
      if strlen(urtTxCache$) > 0 then
        VspMasterRtsSend(0)
      endif
    elseif (hAttr == hVspAttr[VSP_ATTR_INDEX_MDMOUT]) then
      //Modem Out from peer changed
      if (strcmp(aData$, "\01") == 0) then
        #cmpif 0x00000040 : print dbgStart$;"+MDM+ ";vtxcnt
        vspAllowTx = 1
        rc = HndlrBridgeOutPatch()
      else
        #cmpif 0x00000040 : print dbgStart$;"-MDM- ";vtxcnt
        vspAllowTx = 0
      endif
    endif
    rc = BleGattcNotifyRead(hConn, hAttr, aData$, discard)
  endwhile
endfunc 1

//==============================================================================
//NonVsp connection received a notify
//==============================================================================
function HndlrNotifyNonVsp()
  dim hConn, hAttr, aData$, discard, wrLen, nIdx
  do
    rc = BleGattcNotifyRead(hConn, hAttr, aData$, discard)
    if rc!= 0 then
      exitfunc 1
    endif
    nIdx = GetIdxFromHConn(hConn)
    if nIdx>0 then
      sprint #tmpVar$, rspStart$;"IN:";nIdx;", ";hAttr;", ";StrHexize$(aData$);rspTerm$
      UartSendFrom840Ex(tmpVar$)
    endif
  dowhile(1)
endfunc 1

//==============================================================================
// Waited too long for Vsp connection to be encrypted do just drop the connection
//==============================================================================
function HndlrTmrWaitEncr()
  if curState == STATE_VSP_IN_WAIT_ENCR then
    vspDisconSts = CONN_ERROR_UNENCRYPTED
    //Some other error, so just drop the connection
    rc = BleDisconnect(connHandles[HCONN_VSP])
    //Change state
    NewState(STATE_VSP_DISCONNECTING)
  endif
endfunc 1

//==============================================================================
// Function called when there is a VSP overrun
//==============================================================================
function HndlrVspRxOverrun()
  #cmpif 0x00000080 :   print dbgStart$;"VspRx Overrun, uarttx space = ";uartinfo(4);dbgTerm$
endfunc 1

//==============================================================================
// Function for bridging data between the VSP service and the AUX
dim rlyFree
dim rlyBufAV$ : rlyBufAV$ = ""
dim rlyBufVA$ : rlyBufVA$ = ""
//==============================================================================
function HndlrPatchAuxToVsp()
  //Pass data from AUX to VSP
  rlyFree = BleVspInfo(4)
  if rlyFree then
    rc = AuxReadN(rlyBufAV$, rlyFree)
    rc = BleVspWrite(rlyBufAV$)
    strshiftleft(rlyBufAV$, rc)
  endif

  //Pass data from VSP to AUX
  rlyFree = AuxInfo(4)
  if rlyFree then
    rc = BleVspRead(rlyBufVA$, rlyFree)
    AuxSendDataEx(rlyBufVA$)
  endif
endfunc 1

//==============================================================================
// This will be called with the cmd mode pin transitions from 0 to 1 which is
// repurposed in low power mode to reopen the UART
//==============================================================================
function HndlrLowPwrUartPin()
  if GpioRead(lowPowerModePin) then
    //Host wants to wake us up
    UartReOpen()
    AuxReOpen()
      #cmpif 0x00000104 :   DbgMsg("Uart/Aux reopened A")
  else
    //We are allowed to sleep with the uarts closed, so try that if buffers empty
    TimerCancel(TMRNUM_LOWPWR_UARTandAUX)
    UartAuxCloseCond()
  endif
endfunc 1

//==============================================================================
// The UART low power operation timer has expired
//==============================================================================
function HndlrTmrLowPwrUart()
  //#cmpif 0x00000104 :   DbgMsg("Uart Tmr EXPIRE")
  //If in the meantime the timer was restarted do nothing
  if TimerRunning(TMRNUM_LOWPWR_UARTandAUX) == 0 then
    //The buffers have to empty and transmit register should be empty too
    UartAuxCloseCond()
  endif
endfunc 1

//==============================================================================
//BLE message
//==============================================================================
function HndlrBleMsg(nMsgId, nCtx)
  select nMsgId
  case BLE_EVBLEMSGID_CONNECT
    OnConnect(nCtx)

  case BLE_EVBLEMSGID_ENCRYPTED
    OnEncrypted(nCtx)

  case BLE_EVBLEMSGID_UNENCRYPTED
    OnUnencrypted(nCtx)

  case BLE_EVBLEMSGID_DISCONNECT
    //Disconnected see HndlrDisCon

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_NEW_BOND
  #cmpif 0x00000004 :   DbgMsg("New Bond")

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_UPDATED_BOND
  #cmpif 0x00000004 :   DbgMsg("Updated Bond")

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_LESC_PAIRING
  #cmpif 0x00000004 :   DbgMsg("LESC Pairing")

  case BLE_EVBLEMSGID_DISPLAY_PASSKEY
    OnDisplayPasskey(nCtx)

  case BLE_EVBLEMSGID_AUTH_KEY_REQUEST
    #cmpif 0x00000004 :   DbgMsgVal("Auth Key Request, type = ", nCtx)
    OnAuthKeyRequest(nCtx)

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_CONN_TO_BONDED_MASTER
  #cmpif 0x00000004 :   DbgMsg("Conn to Bonded Master ")

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_CONN_PARMS_UPDATE
  #cmpif 0x00000004 :   ShowConnParms(nCtx)

  #cmpif 0x00000004 : case BLE_EVBLEMSGID_CONN_PARMS_UPDATE_FAIL
  #cmpif 0x00000004 :   DbgMsg("Conn Parm Negotiation FAILED")

  case else
    #cmpif 0x00000004 : DbgMsgVal("Unprocessed nMsgId", nMsgId)
  endselect
endfunc 1

//==============================================================================
//==============================================================================
#cmpif 0x00020000 : function HandlerPrimSvc(hConn, hUuid, hStart, hEnd) as integer
#cmpif 0x00020000 :   if hStart!= 0 then
#cmpif 0x00020000 :     //S: hStart, (hEnd), hUuid
#cmpif 0x00020000 :     sprint #tmpVar$, rspStart$;"TM:S:";hStart;" , (";hEnd;") , ";integer.h' hUuid;rspTerm$
#cmpif 0x00020000 :     UartSendFrom840Ex(tmpVar$)
#cmpif 0x00020000 :     if hStart == hEnd then
#cmpif 0x00020000 :       //The service is empty so move on to next service
#cmpif 0x00020000 :       rc = BleDiscServiceFirst(hConn, (hEnd + 1), 0)
#cmpif 0x00020000 :       if rc!= 0 then
#cmpif 0x00020000 :         TerminateTableMap(rc)
#cmpif 0x00020000 :       endif
#cmpif 0x00020000 :     else
#cmpif 0x00020000 :       //And get all characteristics of this service
#cmpif 0x00020000 :       rc = BleDiscCharFirst(hConn, 0, hStart, hEnd)
#cmpif 0x00020000 :       if rc!= 0 then
#cmpif 0x00020000 :         TerminateTableMap(rc)
#cmpif 0x00020000 :       endif
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :   else
#cmpif 0x00020000 :     //Reached end of remote GATT table
#cmpif 0x00020000 :     TerminateTableMap(0)
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 : endfunc 1

//==============================================================================
//==============================================================================
#cmpif 0x00020000 : function HandlerCharDisc(hConn, hUuid, cProp, hVal, hiUuid) as integer
#cmpif 0x00020000 :   if hVal!= 0 then
#cmpif 0x00020000 :     //C: hVal, cProp, hUuid, hiUuid
#cmpif 0x00020000 :     sprint #tmpVar$, rspStart$;"TM: C:";hVal;" , ";integer.h' cProp;" , ";integer.h' hUuid;" , ";hiUuid;rspTerm$     //use UartSendFrom840 instead
#cmpif 0x00020000 :     UartSendFrom840Ex(tmpVar$)
#cmpif 0x00020000 :     //And get all descriptors of this characteristics
#cmpif 0x00020000 :     rc = BleDiscDescFirst(hConn, 0, hVal)
#cmpif 0x00020000 :     if rc!= 0 then
#cmpif 0x00020000 :       TerminateTableMap(rc)
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :   else
#cmpif 0x00020000 :     //No more chars in this service, so go for next service
#cmpif 0x00020000 :     rc = BleDiscServiceNext(hConn)
#cmpif 0x00020000 :     if rc!= 0 then
#cmpif 0x00020000 :       TerminateTableMap(rc)
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 : endfunc 1

//==============================================================================
//==============================================================================
#cmpif 0x00020000 : function HandlerDescDisc(hConn, hUuid, hDesc) as integer
#cmpif 0x00020000 :   if hDesc!= 0 then
#cmpif 0x00020000 :     //D: hDesc, hUuid
#cmpif 0x00020000 :     sprint #tmpVar$, rspStart$;"TM:  D:";hDesc;" , ";integer.h' hUuid;rspTerm$     //use UartSendFrom840 instead
#cmpif 0x00020000 :     UartSendFrom840Ex(tmpVar$)
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 :   //And get all descriptors of this characteristics
#cmpif 0x00020000 :   rc = BleDiscDescNext(hConn)
#cmpif 0x00020000 :   if rc!= 0 then
#cmpif 0x00020000 :     //No more descc in this char, so go for next char
#cmpif 0x00020000 :     rc = BleDiscCharNext(hConn)
#cmpif 0x00020000 :     if rc!= 0 then
#cmpif 0x00020000 :       rc = BleDiscServiceNext(hConn)
#cmpif 0x00020000 :       if rc!= 0 then
#cmpif 0x00020000 :         TerminateTableMap(rc)
#cmpif 0x00020000 :       endif
#cmpif 0x00020000 :     endif
#cmpif 0x00020000 :   endif
#cmpif 0x00020000 : endfunc 1

//==============================================================================
// This handler is called when there when an Indicate is acknowledged
//==============================================================================
function HndlrCharHvc(BYVAL hChar AS INTEGER) as integer
  charIdx = GetIdxFromHChar(hChar)
  if charIdx>0 then
    sprint #tmpVar$, rspStart$;"AK:";charIdx;rspTerm$
    UartSendFrom840Ex(tmpVar$)
  endif
endfunc 1

//==============================================================================
//==============================================================================
function HndlrCharVal(BYVAL hChar AS INTEGER, byval offset, byval len) as integer
  charIdx = GetIdxFromHChar(hChar)
  if charIdx>0 then
    rc = BleCharValueRead(hChar, tmpDta$)
    sprint #tmpVar$, rspStart$;"WR:";charIdx;", ";StrHexize$(tmpDta$);rspTerm$
    UartSendFrom840Ex(tmpVar$)
  endif
endfunc 1

//==============================================================================
//==============================================================================
function HndlrCharCccd(BYVAL hChar AS INTEGER, BYVAL nVal AS INTEGER) as integer
  charIdx = GetIdxFromHChar(hChar)
  if charIdx>0 then
    sprint #tmpVar$, rspStart$;"CC:";charIdx;", ";nVal;rspTerm$
    UartSendFrom840Ex(tmpVar$)
  endif
endfunc 1

//==============================================================================
//==============================================================================
function HndlrCharSccd(BYVAL hChar AS INTEGER, BYVAL nVal AS INTEGER) as integer
  charIdx = GetIdxFromHChar(hChar)
  if charIdx>0 then
    sprint #tmpVar$, rspStart$;"SC:";charIdx;", ";nVal;rspTerm$
    UartSendFrom840Ex(tmpVar$)
  endif
endfunc 1

//==============================================================================
// This handler is called when the packet length is changed
//==============================================================================
function HandlerPacketLength(BYVAL hConn, BYVAL Tx_Octets, BYVAL Tx_Time, BYVAL Rx_Octets, BYVAL Rx_Time)
  #cmpif 0x00000010 :  print dbgStart$;"Pkt-Len_Chg: Tx(Len = ";Tx_Octets;" Time = ";Tx_Time;"us) Rx(Len = ";Rx_Octets;" Time = ";Rx_Time;"us)"
  //Not vspChunkLen is == Tx_Octets-7

  //If this is a VSP connection then update the PHY if not 1MPHY
  if hConn == connHandles[HCONN_VSP] then
    if vspIsOutGoing != FALSE then
      rc = ChangePhy( hConn )
      #cmpif 0x00000001 :  print dbgStart$;"ChangePhy() ret:";integer.h' rc
    endif
  endif

endfunc 1

//==============================================================================
// This handler is called when there is an event that the attribute MTU has changed
//==============================================================================
function HandlerAttrMTU(BYVAL hCOnn AS INTEGER, BYVAL nSize AS INTEGER)
  #cmpif 0x00000010 :  print dbgStart$;"Attribute MTU Changed to Size:";nSize
  vspChunkLen = nSize-3
  //Get connection index from conn handle and send async response if non-VSP
  tmpVar = GetIdxFromHConn(hConn)
  if tmpVar!= HCONN_VSP then
    sprint #tmpVar$, "\nMT:";tmpVar;" ";vspChunkLen;"\r"
    UartSendFrom840Ex(tmpVar$)
  endif
endfunc 1

//==============================================================================
// This handler is called when remote is requesting a switch to a different PHY
//==============================================================================
function  HandlerPhyRequest(BYVAL hConn, BYVAL PhyTx, BYVAL PhyRx)
#cmpif 0x00000010 :    print dbgStart$;"BLE PHY REQUEST: (PhyTx = ";PhyTx;" PhyRx = ";PhyRx;")"
endfunc 1

//==============================================================================
// This handler is called when the BLE PHY is updated
//==============================================================================
function  HandlerPhyUpdated(BYVAL hConn, BYVAL nStatus, BYVAL PhyTx, BYVAL PhyRx)
#cmpif 0x00000010 :     if nStatus == 0 then
#cmpif 0x00000010 :       print dbgStart$;"BLE PHY UPDATED: (PhyTx = ";PhyTx;" PhyRx = ";PhyRx;")"
#cmpif 0x00000010 :     else
#cmpif 0x00000010 :       print dbgStart$;"BLE PHY UPDATE FAIL: ";integer.h' nStatus
#cmpif 0x00000010 :     endif
  //Get connection index from conn handle and send async response if non-VSP
  tmpVar = GetIdxFromHConn(hConn)
  if tmpVar!= HCONN_VSP then
    if nStatus == 0 then
      sprint #tmpVar$, "\nPU:";tmpVar;" ";PhyTx;" ";PhyRx;"\r"
    else
      sprint #tmpVar$, "\nPF:";tmpVar;" ";nStatus;"\r"
    endif
    UartSendFrom840Ex(tmpVar$)
  endif
endfunc 1

//==============================================================================
// On ERROR handler
//==============================================================================
sub HandlerOnErr()
  UartReOpen()

  rc = GetLastError()
  print rspStart$;"OnErr - ";integer.h' rc;rspTerm$
  //Wait for Tx buffer to flush
  while UartInfo(5)>0
  endwhile
  SpinDelay(250)

  #cmpif 0x00040000 :   reset(0)
endsub

//==============================================================================
// This handler is called when there is an NFC event
//==============================================================================
#cmpif 0x00020000 : function HandlerNfc(msgid) as integer
#cmpif 0x00020000 : // Send an asynchronous response only in certain states and certainly
#cmpif 0x00020000 : // not when in a VSP connection.
#cmpif 0x00020000 :   select curState
#cmpif 0x00020000 :   case STATE_IDLE_nonVSP, STATE_IDLE_VSP, STATE_SCAN_VSP, STATE_nonVSP_CONNECTED
#cmpif 0x00020000 :     select(msgid)
#cmpif 0x00020000 :     case NFC_MSGIN_NFCFIELDOFF
#cmpif 0x00020000 :       tmpVar$ = "NS:0"
#cmpif 0x00200000 :       nfcSenseCnt = nfcSenseCnt + 1
#cmpif 0x00020000 :
#cmpif 0x00020000 :     case NFC_MSGIN_NFCFIELDON
#cmpif 0x00020000 :       tmpVar$ = "NS:1"
#cmpif 0x00200000 :       nfcSenseCnt = nfcSenseCnt + 1
#cmpif 0x00020000 :
#cmpif 0x00020000 :     case NFC_MSGIN_NFCTAGREAD
#cmpif 0x00020000 :       tmpVar$ = "NR"
#cmpif 0x00200000 :       nfcReadCnt = nfcReadCnt + 1
#cmpif 0x00020000 :
#cmpif 0x00020000 :     case else
#cmpif 0x00020000 :       exitfunc 1
#cmpif 0x00020000 :     endselect
#cmpif 0x00020000 :     tmpVar$ = rspStart$ + tmpVar$ + rspTerm$
#cmpif 0x00020000 :     UartSendFrom840Ex(tmpVar$)
#cmpif 0x00020000 :   case else
#cmpif 0x00020000 :   endselect
#cmpif 0x00020000 : endfunc 1

//==============================================================================
// This handler is called when data has arrived at the UART serial port
// when in bridge mode 0
//==============================================================================
function HandlerOnUrtRxRelay() as integer
  //Data received from UART
  tmpVar = UartReadN(auxTxCache$, MUX_AUX_MAX_TXCACHE_LEN)
  while tmpVar
    //Bridge to aux
    AuxSendData()
    if auxTxCacheLen>0 then
      //Aux Tx buffer is full
      exitfunc 1
    endif
    tmpVar = UartReadN(auxTxCache$, MUX_AUX_MAX_TXCACHE_LEN)
  endwhile
endfunc 1

//==============================================================================
// This handler is called when data has arrived at the UART serial port
// which in bridge mode 1
dim txlenEsc, rxlenEsc  //to reduce code size
//==============================================================================
function HndlrOnUrtRxRelayEsc() as integer
  //Data received from UART
  rxlenEsc = UartReadN(urtRxRelay$, MUX_UART_RELAY_CHUNK_LEN)
  while rxlenEsc
    //Rx buffer was not empty
    select muxState
    case MUX_STATE_1_HL78_UART_IDLE
      //Bridge to aux
      AuxSendDataEx(urtRxRelay$)
      if (rxlenEsc == 1) then
        if strcmp(urtRxRelay$, muxEsc$) == 0 then
          //It is the escape sequence character
          muxEscCount = muxEscCount + 1
          //#cmpif 0x00000004 :   DbgMsgVal("Inc Esc Count ", muxEscCount)
        else
          //Not escape sequence character
          muxEscCount = 0
          //#cmpif 0x00000004 :   DbgMsg("Reset Esc Count !!")
        endif
      else
        //Definitely not the escape character because we got multiple characters, so reset count
        muxEscCount = 0
        //#cmpif 0x00000004 :   DbgMsg("Reset Esc Count >1")
      endif
      //Change state
      NewMuxState(MUX_STATE_1_HL78)
      //And restart the escape delay timer
      TimerStart(TMRNUM_ESCAPE_DELAY, muxEscDelay, 0)

    case MUX_STATE_1_HL78
      muxEscCount = 0
      //#cmpif 0x00000004 :   DbgMsg("Reset Esc Count")
      //bridge to aux
      AuxSendDataEx(urtRxRelay$)
      //Restart the timer
      TimerStart(TMRNUM_ESCAPE_DELAY, muxEscDelay, 0)

    case else
      #cmpif 0x00000004 :   DbgMsg("unexpected state Esc")
    endselect

    //And empty the buffer as it has all been xferred to the aux Tx cache
    strshiftleft(urtRxRelay$, rxlenEsc)

    //If txcache not empty then we abort
    if auxTxCacheLen > 0 then
      exitfunc 1
    endif

    //Read next chunk from UART buffer
    rxlenEsc = UartReadN(urtRxRelay$, MUX_UART_RELAY_CHUNK_LEN)
  endwhile
endfunc 1

//==============================================================================
// This handler is called when data has arrived at the aux serial port which
// should be relayed straight out to the UART
//==============================================================================
function HandlerOnAuxRxRelay() as integer
  //Data received from AUX
  urtTxCacheLenHL = AuxReadN(urtTxCacheHL$, MUX_AUX_RELAY_CHUNK_LEN)
  while urtTxCacheLenHL
    //Bridge to UART
    UartSendFromHL()
    if urtTxCacheLenHL>0 then
      //UART Tx buffer is full so jump out
      exitfunc 1
    endif
    urtTxCacheLenHL = AuxReadN(urtTxCacheHL$, MUX_AUX_RELAY_CHUNK_LEN)
  endwhile
endfunc 1

//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerAuxTxEmpty() as integer
endfunc 1

//==============================================================================
// This handler is called when there is a BREAK detected on the AUX port
//==============================================================================
#cmpif 0x00000800    : function HandlerAuxBreak() as integer
#cmpifand 0x00000803 :   UartReOpen()
#cmpifand 0x00000803 :   print dbgStart$;"AUX BREAK"
#cmpif 0x00000800    : endfunc 1

//==============================================================================
//==============================================================================
function HandlerAuxCts() as integer
  if AuxInfo(0) then
    //Echo the state of the HL78's CTS line to LED3 on P1.01
    hlUartCts = AuxInfo(7)
    GpioWrite(SIO_HLCTS_ECHO, hlUartCts)

    #cmpif 0x00000004 : if UartInfo(0) then
    #cmpif 0x00000004 :   sprint #dbgmsg$, "Aux: cts = "; hlUartCts ;" cnt = ";AuxInfo(8)
    #cmpif 0x00000004 :   DbgMsg(dbgmsg$)
    #cmpif 0x00000004 : endif

    //Update the HL_SLEEP output ( LED4 on devkit)
    UpdateHlSleepOutput()
  endif
endfunc 1

//==============================================================================
//==============================================================================
function HndlrAuxMonitorRsp() as integer
  if atParse then
    //840 is not busy processing a command
    if AuxInfo(3)>0 then
      //The HL has sent unsolicited data
      DisableUartAuxEvents()
      rc = SendMsgApp(MSGAPP_ENTER_MUXMODE2_HL78_ASYNC_RSP, NULL_CTX)
    endif
  endif
endfunc 1

//==============================================================================
// Polled on AuxRx or UartTxEmpty event in muxMode 2 when waiting for async
// response to end
//==============================================================================
function HndlrDetectAsyncEnd() as integer
  while(1)
    //Flush Tx cache first
    UartSendFromHL()
    if urtTxCacheLenHL>0 then
      //UART Tx buffer is full so jump out
      exitfunc 1
    endif
    //Check if data received from AUX
    muxAuxRxLen = AuxReadN(muxAuxRx$, MUX_AUX_RELAY_CHUNK_LEN)
    if muxAuxRxLen == 0 then
      exitfunc 1
    endif
    select muxSubState
    case 0 //Waiting for first <cr>
      muxCrPos = StrPos(muxAuxRx$, muxCr$, 0)
      if muxCrPos<0 then
        //<cr> has not arrived yet so relay everything
        muxCrPos = muxAuxRxLen
      else
        //<cr> found in the input string so relay up to and including the <cr>
        muxCrPos = muxCrPos + 1
        NewMuxSubState(10) //Wait for <lf> after first <cr>
      endif
      urtTxCacheHL$ = StrSplitLeft$(muxAuxRx$, muxCrPos)

    case 10 //Waiting for <lf> after first <cr>
      urtTxCacheHL$ = StrSplitLeft$(muxAuxRx$, 1)
      if strcmp(urtTxCacheHL$, muxLf$) == 0 then
        //Got the <lf>
        NewMuxSubState(30) //wait for second <cr>
      elseif strcmp(urtTxCacheHL$, muxCr$) == 0 then
        //No nothing and stay in this state
      else
        //Did not get the <lf>
        NewMuxSubState(0)
      endif

    case 30 //Waiting for second <cr>
      muxCrPos = StrPos(muxAuxRx$, muxCr$, 0)
      if muxCrPos<0 then
        //<cr> has not arrived yet so relay everything
        muxCrPos = muxAuxRxLen
      else
        //<cr> found in the input string so relay up to and including the <cr>
        muxCrPos = muxCrPos + 1
        NewMuxSubState(60) //Wait for <lf> after second <cr>
      endif
      urtTxCacheHL$ = StrSplitLeft$(muxAuxRx$, muxCrPos)

    case 60 //Waiting for <lf> after second <cr>
      urtTxCacheHL$ = StrSplitLeft$(muxAuxRx$, 1)
      if strcmp(urtTxCacheHL$, muxLf$) == 0 then
        //Got the <lf>
        //#cmpif 0x00000004 :  DbgMsg("RSP END")
        DisableUartAuxEvents()
        //Change handlers and state
        rc = SendMsgApp(MSGAPP_ENTER_MUXMODE2_840_IDLE, NULL_CTX)
        exitfunc 1
      elseif strcmp(urtTxCache$, muxCr$) == 0 then
        //No nothing and stay in this state
      else
        //Did not get the <lf>
        NewMuxSubState(30)  //wait for second cr again
      endif

    case else
      //We should neve get here, let us jest reset ourselves
      reset(0)
    endselect
  endwhile
endfunc 1


//==============================================================================
// Polled on AuxRx or UartTxEmpty event in muxMode 2 when waiting for
// response to end for a command
//==============================================================================
function HndlrAuxDetectRspEnd() as integer
  while(1)
    //Flush Tx cache first
    UartSendFromHL()
    if urtTxCacheLenHL>0 then
      //UART Tx buffer is full so jump out
      exitfunc 1
    endif
    //Check if data received from AUX
    muxAuxRxLen = AuxReadN(muxAuxRx$, MUX_AUX_RELAY_CHUNK_LEN)
    if muxAuxRxLen == 0 then
      exitfunc 1
    endif

    select muxSubState
    case 0 //Waiting for first <cr>
      muxCrPos = StrPos(muxAuxRx$, muxCr$, 0)
      if muxCrPos<0 then
        //<cr> has not arrived yet so relay everything
        muxCrPos = muxAuxRxLen
      else
        //<cr> found in the input string so relay up to and including the <cr>
        muxCrPos = muxCrPos + 1
        NewMuxSubState(10) //Wait for <lf> after first <cr>
      endif
      urtTxCacheHL$ = StrSplitLeft$(muxAuxRx$, muxCrPos)

    case 10 //Waiting for <lf> after first <cr>
      urtTxCacheHL$ = StrSplitLeft$(muxAuxRx$, 1)
      if strcmp(urtTxCacheHL$, muxLf$) == 0 then
        //Got the <lf>
        StrShiftLeft(muxMatch$, strlen(muxMatch$)) //clear the match string
        NewMuxSubState(20) //wait for second <cr>
      elseif strcmp(urtTxCacheHL$, muxCr$) == 0 then
        //No nothing and stay in this state
      else
        //Did not get the <lf>
        NewMuxSubState(0)
      endif

    case 20 //Wait for second <Cr> and copy first K characters
      if strlen(muxMatch$) < MUX_RESPONSE_TYPE_MATCH_SIZE then
        //Not enough saved
        muxMatch$ = muxMatch$+left$(muxAuxRx$, MUX_RESPONSE_TYPE_MATCH_SIZE)
        muxCrPos = StrPos(muxAuxRx$, muxCr$, 0)
        if muxCrPos<0 then
          //Line content just forward
          muxCrPos = muxAuxRxLen
        else
          //<cr> found in the input string so relay up to and including the <cr>
          muxCrPos = muxCrPos + 1
          NewMuxSubState(60) //Wait for <lf> after second <cr>
          //check if there was a transaction end string
          muxFound = MuxFindMatch()
        endif
        urtTxCacheHL$ = StrSplitLeft$(muxAuxRx$, muxCrPos)
      else
        //Enough saved
        muxFound = MuxFindMatch()
        NewMuxSubState(30)
      endif

    case 30 //Waiting for second <cr>
      muxCrPos = StrPos(muxAuxRx$, muxCr$, 0)
      if muxCrPos<0 then
        //<cr> has not arrived yet so relay everything
        muxCrPos = muxAuxRxLen
      else
        //<cr> found in the input string so relay up to and including the <cr>
        muxCrPos = muxCrPos + 1
        NewMuxSubState(60) //Wait for <lf> after second <cr>
      endif
      urtTxCacheHL$ = StrSplitLeft$(muxAuxRx$, muxCrPos)

    case 60 //Waiting for <lf> after second <cr>
      urtTxCacheHL$ = StrSplitLeft$(muxAuxRx$, 1)
      if strcmp(urtTxCacheHL$, muxLf$) == 0 then
        if muxFound then
          //Got the <lf>
          DisableUartAuxEvents()
          //Change handlers and state
          rc = SendMsgApp(MSGAPP_ENTER_MUXMODE2_840_IDLE, NULL_CTX)
          exitfunc 1
        else
        NewMuxSubState(0)
        endif
      elseif strcmp(urtTxCacheHL$, muxCr$) == 0 then
        //No nothing and stay in this state
      else
        //Did not get the <lf>
        NewMuxSubState(20)  //wait for second cr again
      endif

    case else
      //We should neve get here, let us jest reset ourselves
      reset(0)
    endselect
  endwhile
endfunc 1

//==============================================================================
// called when there is a change of state of the LTE_TX_ON input from the HL78
//==============================================================================
function HandlerOnLteTxOn()
//Safe to use the variable 'tmpVar'
  nCurTXON = GpioRead(SIO_LTE_TX_ON)
  GpioWrite(SIO_TXON_ECHO, nCurTXON)
  #cmpifand 0x00000002 :    DbgMsgVal("TX_ON = ", nCurTXON)

  if tmpVar then
    nTxOnCnt   = (nTxOnCnt + 1) % 1000000
  endif
endfunc 1

//==============================================================================
// called when there is a change of state of the LTE_VGPIO input from the HL78
//==============================================================================
function HandlerOnVGPIO()
  //Doing it via this if statement because it guarantees that nCurVGPIO will be 0 or 1
  //as we are going to use it to index into a string array with 2 elements
  if GpioRead(SIO_LTE_VGPIO) then
    nCurVGPIO = 1
  else
    nCurVGPIO = 0
  endif
  #cmpif 0x00000004 : DbgMsgVal("VGPIO = ", nCurVGPIO)

  //If mux pointing to 840 then send an async response
  SendAsyncHl78Status(vg$[nCurVGPIO])

  //If VGPIO is low then ensure that when AUX TX/RTS are high they do not induce
  //leakage current in the HL7800
  if nCurVGPIO then
    #cmpif 0x00000104 :  DbgMsg("Aux hardware Reopen")
    rc = AuxIoctl(DRIVER_UART_IOCTLID_REOPEN, tmpVar, tmpVar)
  else
    #cmpif 0x00000104 :  DbgMsg("Aux hardware close")
    rc = AuxIoctl(DRIVER_UART_IOCTLID_PARTIALLY_CLOSE, tmpVar, tmpVar)
  endif
      #cmpif 0x00000003 : AssertRC(60680)

  //Keep a count of how VGPIO transitions
  if nCurVGPIO then
    nVGpioCnt = (nVGpioCnt + 1) % 1000000
  endif

  //Update the HL state tracking state machine
  select nHlState
  case HLSTATE_POSTRESET_WAIT_VGPIO
    //NewHlState(HLSTATE_POSTRESET_WAIT_CTS_DEASSERT)
    NewHlState(HLSTATE_POSTRESET_WAIT_DSR_DEASSERT)
  case else
  endselect
endfunc 1

//==============================================================================
// called when there is a change of state of the LTE_GPIO2 input from the HL78
//==============================================================================
function HandlerOnGPIO2()
  //Doing it via this if statement because it guarantees that nCurGPIO2 will be 0 or 1
  //as we are going to use it to index into a string array with 2 elements
  if GpioRead(SIO_LTE_GPIO2) then
    nCurGPIO2 = 1
  else
    nCurGPIO2 = 0
  endif
  #cmpif 0x00000004 : DbgMsgVal("GPIO2 = ", nCurGPIO2)

  //If mux pointing to 840 then send an async response
  SendAsyncHl78Status(g2$[nCurGPIO2])

  if nCurGPIO2 then
    nGpio2Cnt = (nGpio2Cnt + 1) % 1000000
  endif
endfunc 1

//==============================================================================
// called when there is a change of state of the LTE_GPIO6 input from the HL78
//==============================================================================
function HandlerOnGPIO6()
  //Doing it via this if statement because it guarantees that nCurGPIO6 will be 0 or 1
  //as we are going to use it to index into a string array with 2 elements
  if GpioRead(SIO_LTE_GPIO6) then
    nCurGPIO6 = 1
  else
    nCurGPIO6 = 0
  endif
  #cmpif 0x00000004 : DbgMsgVal("GPIO6 = ", nCurGPIO6)

  //If mux pointing to 840 then send an async response
  SendAsyncHl78Status(g6$[nCurGPIO6])

  if nCurGPIO6 then
    nGpio6Cnt = (nGpio6Cnt + 1) % 1000000
  endif
endfunc 1

//==============================================================================
// called when there is a change of state of the LTE_UART1_DSR input from the HL78
//==============================================================================
function HandlerOnUART1DSR()
  //Doing it via this if statement because it guarantees that nCurUART1DSR will be 0 or 1
  //as we are going to use it to index into a string array with 2 elements
  if GpioRead(SIO_LTE_UART1_DSR) then
    nCurUART1DSR = 1
  else
    nCurUART1DSR = 0
  endif
  #cmpif 0x00000004 : DbgMsgVal("UART1_DSR = ", nCurUART1DSR)

  //If mux pointing to 840 then send an async response
  SendAsyncHl78Status(ds$[nCurUART1DSR])

  //Update the HL state tracking state machine
  select nHlState
  case HLSTATE_POSTRESET_WAIT_DSR_DEASSERT
    if nCurUART1DSR == 1 then
      //DSR is now deasserted
      NewHlState(HLSTATE_POSTRESET_WAIT_DSR_ASSERT)
    endif
  case HLSTATE_POSTRESET_WAIT_DSR_ASSERT
    if nCurUART1DSR == 0 then
      //DSR is now asserted
      NewHlState(HLSTATE_RUN)
      //Cancel timer
      TimerCancel(TMRNUM_HLSTATE_TRACK)
    endif
  case else
  endselect

  if nCurUART1DSR then
    nUart1DsrCnt = (nUart1DsrCnt + 1) % 1000000
  endif
endfunc 1

//==============================================================================
// Waited too long for HL state machine so initialise by estimate
//==============================================================================
function HndlrHLStateTmr()
  #cmpifand 0x00000002 :    DbgMsg("HL State Tmr Expire")
  if nHlState < HLSTATE_RUN then
    NewHlState(HLSTATE_RUN)
  elseif nCurVGPIO == 0 then
    NewHlState(HLSTATE_HIBERNATE)
  elseif nCurUART1DSR == 1 then
    //UART1_DSR is deasserted
    NewHlState(HLSTATE_SLEEP)
  elseif (GpioRead(SIO_LTE_WAKE) == 1) || (nUartDtr == 0) then
    //WAKE pin is high OR UART1_DTR is asserted
    NewHlState(HLSTATE_RUN)
  else
    NewHlState(HLSTATE_LITE_HIBERNATE)
  endif
endfunc 1

//==============================================================================
// Check temperature of chip to see which crystal should be used
//==============================================================================
function HndlrTempCheck()
  dim val
  val = sysinfo(2024)

  if (val <= SRegGet(CfgId_HFClock_Switch_degC)) then
    //Below threshold - external
    if (External32Mhz == 0) then
      BleConfigHfClock(1)
      External32Mhz = 1
    endif
  elseif (val >= (SRegGet(CfgId_HFClock_Switch_degC) + SRegGet(CfgId_HFClockHysteresis_degC))) then
    //At or above hysteresis threshold - internal
    if (External32Mhz == 1) then
      BleConfigHfClock(0)
      External32Mhz = 0
    endif
  endif
endfunc 1


//******************************************************************************
//Setup event handlers
//******************************************************************************
OnError NEXT                    HandlerOnErr

OnEvent EVBLEMSG                call HndlrBleMsg
OnEvent EVBLE_SCAN_TIMEOUT      call HndlrScanTimeout
OnEvent EVBLE_ADV_REPORT        call HndlrAdvReport
OnEvent EVBLE_CONN_TIMEOUT      call HndlrConnTout
OnEvent EVDISCON                call HndlrDisCon
OnEvent EVFINDDESC              call HndlrFindDesc
OnEvent EVFINDCHAR              call HndlrFindChar
OnEvent EVATTRWRITE             call HandlerAttrWrite
OnEvent EVATTRREAD              call HndlrAttrRead
OnEvent EVTMR_ENCR_WAIT         call HndlrTmrWaitEncr
OnEvent EVCHARHVC               call HndlrCharHvc
OnEvent EVCHARVAL               call HndlrCharVal
OnEvent EVCHARCCCD              call HndlrCharCccd
OnEvent EVCHARSCCD              call HndlrCharSccd

OnEvent EVTMR_DATA_PUMP         call HndlrTmrVspPump

#cmpif 0x00020000 : OnEvent EVDISCPRIMSVC           call HandlerPrimSvc
#cmpif 0x00020000 : OnEvent EVDISCCHAR              call HandlerCharDisc
#cmpif 0x00020000 : OnEvent EVDISCDESC              call HandlerDescDisc

OnEvent EVPACKETLENGTH          call HandlerPacketLength
OnEvent EVATTRIBUTEMTU          call HandlerAttrMTU
OnEvent EVBLE_PHY_REQUEST       call HandlerPhyRequest
OnEvent EVBLE_PHY_UPDATED       call HandlerPhyUpdated

#cmpif 0x00200000 : OnEvent EVNFC                   call HandlerNfc

//Events for UART low operation
OnEvent EVGPIOCHAN_LOWPWR_UART    call HndlrLowPwrUartPin      //BUTTON4 (default)
OnEvent EVTMR_LOWPWR_UARTandAUX   call HndlrTmrLowPwrUart

#cmpif 0x00000800 : OnEvent EVAUXBREAK              call HandlerAuxBreak

//Pinnacle specific event handling
OnEvent EVGPIOCHAN_LTE_TX_ON          call HandlerOnLteTxOn
OnEvent EVGPIOCHAN_LTE_VGPIO          call HandlerOnVGPIO
OnEvent EVGPIOCHAN_LTE_GPIO2          call HandlerOnGPIO2
OnEvent EVGPIOCHAN_LTE_GPIO6          call HandlerOnGPIO6
OnEvent EVGPIOCHAN_LTE_UART1_DSR      call HandlerOnUART1DSR

OnEvent EVAUXCTS                      call HandlerAuxCts
OnEvent EVTMR_HLSTATE_TRACK           call HndlrHLStateTmr

OnEvent EVTMR_TEMPERATURE_CHECK       call HndlrTempCheck

//******************************************************************************
// This section contains routines that reference handlers and so given that
// smartBASIC is not capable of calling functions that are not defined yet
// this is as late as possible where we can place code.
//******************************************************************************

//------------------------------------------------------------------------------
// Mux Mode update handlers based on state of sio pin muxSio.
// If low then points to HL, if high then points to 840
//------------------------------------------------------------------------------
sub Mode0UpdateHandlers()
  if GpioRead(muxSio) then
    //HIGH means connect UART traffic to 840 AT Cmd Processor
    OnEvent EVUARTRX       call HndlrUartCmd
    OnEvent EVUARTTXEMPTY  call HndlrUartRspPump
    OnEvent EVAUXRX        call HndlrAuxRxNoAction
    OnEvent EVAUXTXEMPTY   call HndlrAuxTxEmptyNoAct
    NewMuxState(MUX_STATE_0_840)
    //Flush appropriate buffers
    strshiftleft(urtRxBuf$, strlen(urtRxBuf$))
    if UartInfo(0) then
      uartflush(1) //Only flush the UART Rx buffer
    endif
    #cmpif 0x00000004 :  DbgMsg("UART<->840 0")
    //Indicate that the UART is directed to 840
    muxToHL = 0
    UartSendFrom840()
  else
    //LOW means connect UART traffic to HL78
    OnEvent EVUARTRX       call HandlerOnUrtRxRelay
    OnEvent EVUARTTXEMPTY  call HandlerOnAuxRxRelay
    OnEvent EVAUXRX        call HandlerOnAuxRxRelay
    OnEvent EVAUXTXEMPTY   call HandlerOnUrtRxRelay
    NewMuxState(MUX_STATE_0_HL78)
    //And tickle the handlers to exchange data just in case there is data
    //siting in the buffer
    if UartInfo(0) && AuxInfo(0) then
      rc = HandlerOnUrtRxRelay()
      rc = HandlerOnAuxRxRelay()
      #cmpif 0x00000004 :  DbgMsg("UART<->HL  0")
    endif
    //Indicate that the UART is directed to HL
    muxToHL = 1
    UartSendFromHL()
  endif
  //Update the status pin which on the devkit drives LED1
  GpioWrite(SIO_MUX_STATUS, muxToHL)
endsub

//------------------------------------------------------------------------------
// Mux Mode update handlers based on non-GPIO state
// nRelay
//    0    Uart detects escape sequence and Aux is relayed to Uart
//    1    Uart directed to 840 and Aux not read
//------------------------------------------------------------------------------
sub Mode1UpdateHandlers( nRelay )  //For nRelay see #defines MUXMODE_1_POINT_TO_XXX
  select nRelay
    case 0 //Uart detects escape sequence and Aux is relayed to Uart
      OnEvent EVUARTRX       call HndlrOnUrtRxRelayEsc
      OnEvent EVUARTTXEMPTY  call HandlerOnAuxRxRelay
      OnEvent EVAUXRX        call HandlerOnAuxRxRelay
      OnEvent EVAUXTXEMPTY   call HndlrOnUrtRxRelayEsc
      NewMuxState(MUX_STATE_1_HL78)
      //And tickle the handlers to exchange data just in case there is data
      //siting in the buffer
      if UartInfo(0) && AuxInfo(0) then
        rc = HndlrOnUrtRxRelayEsc()
        rc = HandlerOnAuxRxRelay()
        #cmpif 0x00000004 :  DbgMsg("UART<->HL 1")
      endif
      //Set mux status pin high so that host knows data is routed to the HL78
      muxToHL = 1
      UartSendFromHL()

    case else  //Uart directed to 840 and Aux not read
      OnEvent EVUARTRX       call HndlrUartCmd
      OnEvent EVUARTTXEMPTY  call HndlrUartRspPump
      OnEvent EVAUXRX        call HndlrAuxRxNoAction
      OnEvent EVAUXTXEMPTY   call HndlrAuxTxEmptyNoAct
      NewMuxState(MUX_STATE_1_840)
      //Flush appropriate buffers
      strshiftleft(urtRxBuf$, strlen(urtRxBuf$))
      if UartInfo(0) then
        uartflush(1) //Only flush the UART Rx buffer
      endif
      #cmpif 0x00000004 :  DbgMsg("UART<->840 1")
      //Set mux status pin low so that host knows data is routed to the 840
      muxToHL = 0
      UartSendFrom840()

  endselect
  //Update the status pin which on the devkit drives LED1
  GpioWrite(SIO_MUX_STATUS, muxToHL)
endsub

//------------------------------------------------------------------------------
// Mux Mode update handlers based on intelligent detection so that the value
// of muxState defines what handlers are registered
//------------------------------------------------------------------------------
sub Mode2UpdateHandlers( nNewState )
  select nNewState
    case MUX_STATE_2_840_IDLE
      OnEvent EVUARTRX       call HndlrUartCmdMode2
      OnEvent EVUARTTXEMPTY  call HndlrUartRspPump
      OnEvent EVAUXRX        call HndlrAuxMonitorRsp
      OnEvent EVAUXTXEMPTY   call HndlrAuxNoAction2
      //Indicate that UART is directed to 840
      muxToHL = 0
      AtParserResume()

    case MUX_STATE_2_840_PATCH
      OnEvent EVUARTRX       call HndlrUartCmdMode2
      OnEvent EVUARTTXEMPTY  call HndlrUartRspPump
      OnEvent EVAUXRX        call HndlrAuxNoAction2
      OnEvent EVAUXTXEMPTY   call HndlrAuxNoAction2
      //Indicate that UART is directed to 840
      muxToHL = 0
      AtParserResume()

    case MUX_STATE_2_HL78_BUSY
      OnEvent EVUARTRX       call HndlrAuxNoAction2
      OnEvent EVUARTTXEMPTY  call HndlrAuxDetectRspEnd
      OnEvent EVAUXRX        call HndlrAuxDetectRspEnd
      OnEvent EVAUXTXEMPTY   call HndlrAuxNoAction2
      //Indicate that the UART is directed to HL
      muxToHL = 1

    case MUX_STATE_2_HL78_ASYNC_RSP
      OnEvent EVUARTRX       call HndlrAuxNoAction2
      OnEvent EVUARTTXEMPTY  call HndlrDetectAsyncEnd
      OnEvent EVAUXRX        call HndlrDetectAsyncEnd
      OnEvent EVAUXTXEMPTY   call HndlrAuxNoAction2
      //Indicate that the UART is directed to HL
      muxToHL = 1
      rc = HndlrDetectAsyncEnd()

    case else  //Uart directed to 840 and Aux not read
      #cmpif 0x00000004 :  DbgMsg("MuxMode 2 unknown state")
      exitsub

  endselect

  //Update the status pin which on the devkit drives LED1
  GpioWrite(SIO_MUX_STATUS, muxToHL)

  NewMuxSubState(0)
  //#cmpif 0x00000004 :  DbgMsg("muxSubState = 0")
  NewMuxState(nNewState)
endsub

//------------------------------------------------------------------------------
// Configure the mux sio specified by S120 as input and will override the Mux
// status output that is routed to LED1 on the devkit.
//------------------------------------------------------------------------------
sub ConfigMuxSio()
  //Set the status pin first as digital ouput with default high (switched to HL)
  //so that it can be overridden with mux output if required
  rc = GpioSetFunc(SIO_MUX_STATUS, SIOTYPE_DOUT, OUTPUT_INIT_HI)

  //Get the GPIO to use for multiplexing control
  muxSio = SRegGet(CfgId_MultiplexerSwitcherSio)
  #cmpif 0x00000004 :   DbgMsgVal( "muxSio = ", muxSio)

  //Set the pin as digital input with no pull resistor
  rc = GpioSetFunc(muxSio, SIOTYPE_DIN, INPUT_PULL_NONE)
  #cmpif 0x00000003 : AssertRC(58720)

  //Attach a bind event to the mux control pin
  select muxMode
  case MULTIPLEXER_MODE_GPIO
    // detect both low to high and high to low changes
    rc = GpioBindEvent(BINDEVENT_MUX_CONTROL, muxSio, DETECT_TOGGLE)
    #cmpif 0x00000003 : AssertRC(61220)

  case MULTIPLEXER_MODE_NONGPIO
    //Only detect low to high changes
    rc = GpioBindEvent(BINDEVENT_MUX_CONTROL, muxSio, DETECT_LO_TO_HI)
    #cmpif 0x00000003 : AssertRC(61260)

  case else
    //No event binding
  endselect
endsub

//------------------------------------------------------------------------------
// Process start-up flags
//------------------------------------------------------------------------------
sub ProcStartupFlags()
  dim scanPat$

  vspAdded = 0
  //Check if need to make connectable for VSP
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  if (startflags & 0x00000001) then
    //Get default parameters
    VspGetDefs()
    //Open the VSP service and variable vspAdded will be updated if not in mux mode 0
    if muxMode != MULTIPLEXER_MODE_GPIO then
      //VSP is only allowed when not in mux mode 0
      rc = VspOpen()
    endif
    if (vspAdded != 0) then
      if (TrustedDevices()>= vspMinTrusted) then
        #cmpif 0x00000004 : DbgMsg("Trusted Database  - not empty")
        //Create the VSP related Advert report and scan report and commit
        VspAdvCreateCommit()
        //Start Advertising
        VspStartAdverts()
        //Change state
        NewState(STATE_IDLE_VSP)
      else
        #cmpif 0x00000004 : DbgMsg("Trusted Database  - is empty")
        NewState(STATE_IDLE_nonVSP)
      endif
    endif
  endif
  if vspAdded == 0 then
    //VSP was not added
    //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
    if ((startflags & 0x00000006) == 0) then
      //Do not start advertising or scanning
      NewState(STATE_IDLE_nonVSP)
      exitsub
    endif
    //Check if adverts to be started
    //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
    if ((startflags & 0x00000002) == 0x00000002) then
      //Need to start advertising in idle
      IdleAdvCommit()
      //Start Advertising
      IdleStartAdverts(idleAdvType, idleAdvIntvlMs)
      //#cmpif 0x00000004 : DbgMsg("IDLE_ADV_SCN adverts started")
    endif
    //Check if scanning to be started
    //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
    if ((startflags & 0x00000004) == 0x00000004) then
      //Need to start scanning in idle
      scanPat$ = SRegGetStr$( CfgIdStr_ScanPattern )
      rc = ScanningStart(0, scanPat$, SRegGet(CfgId_ScanRssiMinimum))
      //#cmpif 0x00000004 : DbgMsg("IDLE_ADV_SCN scanning started")
    endif
    //Change state
    advPrefix$ = "AD0:"
    NewState(STATE_IDLE_nonVSP)
  endif
endsub

//------------------------------------------------------------------------------
// Perform initialisation specific to Pinnacle
//------------------------------------------------------------------------------
sub PinnacleStartup()
  //Detect changes to LTE_TX_ON (P1.03)so that they can be displayed on LED3 (P1.06)
  rc = GpioBindEvent(BINDEVENT_LTE_TX_ON, SIO_LTE_TX_ON, DETECT_TOGGLE)
  #cmpif 0x00000003 : AssertRC(59490)

  //Detect changes to LTE_VGPIO
  rc = GpioBindEvent(BINDEVENT_LTE_VGPIO, SIO_LTE_VGPIO, DETECT_TOGGLE)
  #cmpif 0x00000003 : AssertRC(61900)
  nCurVGPIO = GpioRead(SIO_LTE_VGPIO)

  //Detect changes to LTE_GPIO2
  rc = GpioBindEvent(BINDEVENT_LTE_GPIO2, SIO_LTE_GPIO2, DETECT_TOGGLE)
  #cmpif 0x00000003 : AssertRC(61940)
  nCurGPIO2 = GpioRead(SIO_LTE_GPIO2)

  //Detect changes to LTE_GPIO6
  rc = GpioBindEvent(BINDEVENT_LTE_GPIO6, SIO_LTE_GPIO6, DETECT_TOGGLE)
  #cmpif 0x00000003 : AssertRC(64380)
  nCurGPIO6 = GpioRead(SIO_LTE_GPIO6)

  //Detect changes to LTE_UART1_DSR
  rc = GpioBindEvent(BINDEVENT_LTE_UART1_DSR, SIO_LTE_UART1_DSR, DETECT_TOGGLE)
  #cmpif 0x00000003 : AssertRC(61980)
  nCurUART1DSR = GpioRead(SIO_LTE_UART1_DSR)

  //Configure P1.06 as output as it drives LED3 on devkit - init OFF
  rc = gpiosetfunc(SIO_TXON_ECHO, SIOTYPE_DOUT, OUTPUT_INIT_LOW)
  #cmpif 0x00000003 : AssertRC(59570)

  //Configure P1.05 (LED2) as output and so the the HL78's CTS can be echoed there
  rc = GpioSetFunc(SIO_HLCTS_ECHO, SIOTYPE_DOUT, OUTPUT_INIT_LOW)
  #cmpif 0x00000003 : AssertRC(59840)

  //Configure an output pin to indicate that the HL78 is in sleep mode - LED4
  //rc = gpiosetfunc(SIO_HL78_SLEEP, SIOTYPE_DOUT, OUTPUT_INIT_LOW)
  //#cmpifand 0x00000003 : AssertRC(59650)

  //Configure an output pin to indicate that the HL78 is not ready for AT commands
  rc = gpiosetfunc(SIO_HL78_READY, SIOTYPE_DOUT, OUTPUT_INIT_HI)
  #cmpifand 0x00000003 : AssertRC(59655)

  //Configure P1.08 as input with pullup as BUTTON3 on devkit as it is the new Autorun (assert high)
  rc = GpioSetFunc(SIO_ALT_AUTORUN, SIOTYPE_DIN, INPUT_PULL_UP)
  #cmpifand 0x00000003 : AssertRC(61830)

  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  // Finally reset the HL if enabled via SReg 124
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  if SRegGet(CfgId_ResetModemOnStartup) then
    GpioWrite(SIO_LTE_RESET, 0)
    SpinDelay(LTE_RESET_STARTUP_ASSERT_TIME_MS)
    GpioWrite(SIO_LTE_RESET, 1)
    //Initialise HL State
    SetHlStateOnResetRel()
    //Start HL track timer
    TimerStart(TMRNUM_HLSTATE_TRACK, HL_MAX_STARTUP_TIME_MS, 0)
  endif
endsub

//------------------------------------------------------------------------------
// This routine starts the show
//------------------------------------------------------------------------------
sub Startup()
  dim i

  //Initial nonVsp connection handle array
  for i = 0 to MAX_CONNECTIONS
    connHandles[i] = INVALID_CONN_HANDLE
  next

  //Initial UUID handle array
  for i = 0 to (MAX_UUID_HANDLES - 1)
    uuidHandles[i] = INVALID_UUID_HANDLE
  next

  //Initialise the first metadata handle to 0 and will remain that way
  metaHandles[0] = 0

  //Set SRegister values from non-vol memory
  SReg8SetCache()
  SReg16SetCache()
  SReg32SetCache()
  SRegStrSetCache()

  //Wait for Tx buffer to flush
  #cmpif 0x00000001 : while UartInfo(5)>0
  #cmpif 0x00000001 : endwhile

  //Get start-up flags
  startflags = SRegGet(CfgId_StartupFlags)
  extraFlags = SRegGet(CfgId_ExtraFlags)

  //Update config keys and reset if required
  dim nUpdated, newVal : nUpdated = 0

  //Configure for high bandwidth
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  #cmpif 0x00100000 : if (((startflags>>5) & 0x00000003) == 0x01) then
  #cmpif 0x00100000 :   //If long range is enabled then highbandwidth needs to be forced to enabled
  #cmpif 0x00100000 :   newVal = 1
  #cmpif 0x00100000 : else
    //Else use bit 3 of startflags to define highbandwidth
    //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
    newVal = ((startflags>>3) & 0x00000001)
  #cmpif 0x00100000 : endif
  SetConfigKey(ENABLE_HIGH_BANDWIDTH_KEY_ID, newVal, nUpdated)       //Bandwidth set

  //Update Data Length Extension related config keys
  //Note: Using Magic numbers to make it more difficult as a change will need to be reflected in user guide
  if ((startflags>>4)&0x00000001) then
    vspAttrMaxLen = DLE_ATTRIBUTE_SIZE
  else
    vspAttrMaxLen = DEFAULT_ATTRIBUTE_SIZE
  endif
  SetConfigKey(ATTRIBUTE_DATA_LENGTH_KEY_ID, vspAttrMaxLen,     nUpdated) //Maximum size of attributes
  SetConfigKey(ATTRIBUTE_MTU_KEY_ID,        (vspAttrMaxLen+3),  nUpdated) //Maximum size of ATT_MTU
  SetConfigKey(BLE_MAX_PACKET_LENGTH_KEY_ID, (vspAttrMaxLen+3+4), nUpdated) //Maximum size of on-air packet length
  if extraFlags & EXTRA_FLAGS_DONTRELOCATE_AUTORUN then
    tmpVar = SIO_nAUTORUN + AUTORUN_ASSERT_LOW     //Leave Autorun pin on default
  else
    tmpVar = SIO_ALT_AUTORUN + AUTORUN_ASSERT_HIGH //Relocate autorun
  endif
  #cmpif 0x10000000 : tmpVar = SIO_nAUTORUN + AUTORUN_ASSERT_LOW
  SetConfigKey(AUTORUN_SIO_KEY_ID,           tmpVar           , nUpdated) //Autorun pin and assert level

  //If any config keys were changed then reset module so they come into effect
  if nUpdated>0 then
    reset(0)
  endif

  vspChunkLen = DEFAULT_ATTRIBUTE_SIZE

  //Initialise uart/aux parameter cache
  InitUrtAuxCache()
  //Setup the UART
  InitUART()

  #cmpif 0x00000001 : print dbgStart$;"startFlags = 0x";integer.h' startflags
  #cmpif 0x00000004 : DbgMsgVal("AttrMaxLen = ", vspAttrMaxLen)

  //Initialise the GPIO
  InitGPIO()

  //Setup and open the auxiliary serial port
  OpenAuxPort()

  //Initialise the mux state
  muxState = MUX_STATE_INIT
  //Get the multiplexer mode for managing the uart/aux bridging
  muxMode = SRegGet(CfgId_MultiplexerMode)
  #cmpif 0x00000004 : DbgMsgVal( "MuxMode = ", muxMode)
  //Configure mux sio
  ConfigMuxSio()
  //Assume HL78 status async responses allowed when pointing to 840 and enabled
  if extraFlags & EXTRA_FLAGS_ENABLE_HL_ASYNCRESP then
    fHlAsycSend = 1
  else
    fHlAsycSend = 0
  endif
  //Assume HL78 status async responses allowed when pointing to 840 and enabled
  if extraFlags & EXTRA_FLAGS_ENABLE_AUXRX_ASYNCRESP then
    fHlAuxRx = 1
  else
    fHlAuxRx = 0
  endif
  //Configure mode
  select muxMode
  case MULTIPLEXER_MODE_NONGPIO
    //Cache the escape sequence delay
    muxEscDelay = SRegGet(CfgId_MultiplexerEscDelayMs)
    #cmpif 0x00000004 :   DbgMsgVal( "muxEscDelay = ", muxEscDelay)
    #cmpif 0x00000004 : //Check that the escape sequence is only one-character wide
    #cmpif 0x00000004 : if strlen(muxEsc$)!= 1 then
    #cmpif 0x00000004 :   DbgMsg("Defaulting Mux Esc")
    #cmpif 0x00000004 :   muxEsc$ = "!"
    #cmpif 0x00000004 : endif
    //Fill string with MUX_ESCAPE_MAXCOUNT backspaces
    #cmpif 0x00800000 : rc = StrFill(muxBackSpc$, 0x08, MUX_ESCAPE_MAXCOUNT)
    if SRegGet( CfgId_MultiplexerMode1Def ) == 0 then
      //Start with UART processed by 840
      Mode1UpdateHandlers(MUXMODE_1_POINT_TO_840)
    else
      //Start with UART processed by HL
      Mode1UpdateHandlers(MUXMODE_1_POINT_TO_HL78)
    endif

  case MULTIPLEXER_MODE_INTELLIGENT
    fHlAsycSend = 0  //Disallow HL78 status when mux points to 840
    //start with aurt processed by 840
    Mode2UpdateHandlers(MUX_STATE_2_840_IDLE)

  case else  //Includes 'case MULTIPLEXER_MODE_GPIO'
    //update UART and aux handlers
    Mode0UpdateHandlers()

  endselect

  //Configure Pairing Capability
  PairingConfig()

  //Initialise the GAP Service
  GapServiceGetDefs()  //into sArg$[] and nArg[]
  rc = GapServiceUpdate()

  //Cache & Config Scanning parameters
  CacheConfigScanParms()

  //Pre-create the idle more advert reports
  IdleAdvCreate()
  CacheAdvertType() //Cache variable idleAdvType with SReg value
  idleAdvIntvlMs = SRegGet(CfgId_IdleAdvertIntvlMs)

  //Get start-up flags
  ProcStartupFlags()

  //Perform Pinnacle-100 related startup
  PinnacleStartup()
endsub

//==============================================================================
// Called when the state of MUX_CONTROL SIO changes.
//==============================================================================
function HandlerMux0GpioChng() as integer
  Mode0UpdateHandlers()
endfunc 1

//==============================================================================
// Called when the state of MUX_CONTROL SIO changes.
//==============================================================================
function HandlerMux1GpioChng() as integer
  //Only allow changes if not in VSP connection
  if IsVspTunneledToHL() == 0 then
    if muxToHL then
      //Currently pointing to HL78
      Mode1UpdateHandlers(MUXMODE_1_POINT_TO_840)
    else
      //Currently pointing to 840
      Mode1UpdateHandlers(MUXMODE_1_POINT_TO_HL78)
    endif
  endif
endfunc 1

//==============================================================================
// Called when the state escape sequence timer has expired.
//==============================================================================
function HndlrTmrEscSeq() as integer
  if muxState == MUX_STATE_1_HL78 then
    if muxEscCount>= MUX_ESCAPE_MAXCOUNT then
      Mode1UpdateHandlers(MUXMODE_1_POINT_TO_840)  //Will change state to MUX_STATE_1_840
      //Send appropriate number of backspaces
      #cmpif 0x00800000 : AuxSendDataEx(muxBackSpc$)
      //Send OK response out to host
      AppendRspEnd(RSP_OK, urtTxCache$)
      //Send out data waiting in buffer
      UartSendFrom840()
    else
      //We still need more escape characters to arrive
      NewMuxState(MUX_STATE_1_HL78_UART_IDLE)
    endif
  endif
endfunc 1

//==============================================================================
// Called when the at parser has transitioned from suspended to resumed
//==============================================================================
sub OnAtParserResumed()
  select muxState
  case MUX_STATE_2_840_IDLE
    rc = HndlrAuxMonitorRsp()
  case else
  endselect
endsub

//==============================================================================
// If the mux is pointing to HL then force it to 840
//==============================================================================
sub ForceMuxTo840()
  //#cmpif 0x00000004 :   DbgMsgVal("ForceMuxTo840() muxm = ", muxMode)
  select muxMode
  case MULTIPLEXER_MODE_NONGPIO
    if muxToHL == 1 then
      Mode1UpdateHandlers(MUXMODE_1_POINT_TO_840)
    endif

  case MULTIPLEXER_MODE_INTELLIGENT
    //#cmpif 0x00000004 :   DbgMsg("Intelligent Mode")
    Mode2UpdateHandlers(MUX_STATE_2_840_PATCH)

  case else
  endselect
endsub

//==============================================================================
// This handler is called process an event thrown by this application used
// for serialisation
// MUST be the last handler as it needs to be call any function defined in
// this application
//==============================================================================
function HndlrMessageApp(nMsgId, nCtx)
  select nMsgId
  case MSGAPP_PROCESS_UART
    //Process the UART as if we just got some uart activity
    OnEvent EVUARTRX              Call HndlrUartCmd
    rc = HndlrUartCmd()

  case MSGAPP_ENTER_NONVSP_CONN_STATE
    OnEvent EVATTRNOTIFY          Call HndlrNotifyNonVsp
    //Also trigger a reprocessing of the UART buffer just in case
    rc = SendMsgApp(MSGAPP_PROCESS_UART, NULL_CTX)

  case MSGAPP_ENTER_VSPOUT_CONN_STATE  //NCTx is the new state to enter
    #cmpif 0x00000004 :   DbgMsg("Going For VSPOUT")
    //Flip UART away from HL if pointed that way
    ForceMuxTo840()
    //Allow TX
    vspAllowTx = 1
    //Send the connect response
    AppendConnRspEnd(CONN_OK, urtTxCache$ )
    //Send out data waiting in buffer
    UartSendFrom840()
    //Change UART and VSP handlers
    OnEvent EVAUXRX             Call HndlrBridgeOutPatch
    OnEvent EVNOTIFYBUF         Call HndlrBridgeOutPatch  //Notify buffers available to send data on air
    OnEvent EVATTRNOTIFY        Call HndlrNotifyVspOut    //data arrived over the air
    OnEvent EVAUXTXEMPTY        Call HndlrAuxTxEmptyOut
    //Enable incoming data from peer
    VspMasterRtsSend(1)
    //Change state
    NewState(nCtx)

  case MSGAPP_ENTER_VSPIN_CONN_STATE  //NCTx is the new state to enter
    #cmpif 0x00000004 :   DbgMsg("Going For VSPIN")
    //Flip UART away from HL if pointed that way
    ForceMuxTo840()
    //Send the connect response
    AppendConnRspEnd(CONN_OK, urtTxCache$ )
    //Send out data waiting in buffer
    UartSendFrom840()
    //Change UART and VSP handlers
    #cmpif 0x00080000 : OnEvent EVVSPRXOVRN           Call HndlrVspRxOverrun
    #cmpif 0x00000004 : DbgMsg("HndlrPatchAuxToVsp")
    OnEvent EVVSPRX             Call HndlrPatchAuxToVsp
    OnEvent EVAUXRX             Call HndlrPatchAuxToVsp
    OnEvent EVVSPTXEMPTY        Call HndlrPatchAuxToVsp
    OnEvent EVAUXTXEMPTY        Call HndlrPatchAuxToVsp
    //Start bridging cached data
    rc = HndlrPatchAuxToVsp()
    //Change state
    NewState(nCtx)

  case MSGAPP_ENTER_MUXMODE1_HL78
    //Send an OK response
    AppendRspEnd(RSP_OK, urtTxCache$)
    //Send out data waiting in buffer
    UartSendFrom840()
    //Adjust the handlers so that we are bridged to HL78
    Mode1UpdateHandlers(MUXMODE_1_POINT_TO_HL78)
    //Reset escape character count
    muxEscCount = 0
    #cmpif 0x00000004 :   DbgMsg("Reset Esc Count #")
    //Start the escape delay timer
    TimerStart(TMRNUM_ESCAPE_DELAY, muxEscDelay, 0)

  case MSGAPP_ENTER_MUXMODE2_840_IDLE
    //Change handlers and state
    Mode2UpdateHandlers(MUX_STATE_2_840_IDLE)

  case MSGAPP_ENTER_MUXMODE2_HL78_BUSY
    //Change handlers and state
    Mode2UpdateHandlers(MUX_STATE_2_HL78_BUSY)

  case MSGAPP_ENTER_MUXMODE2_HL78_ASYNC_RSP
    //Change handlers and state
    Mode2UpdateHandlers(MUX_STATE_2_HL78_ASYNC_RSP)

  case MSGAPP_PROCESS_PARSER_RESUMED
    //The at parser has transitioned from suspended to resumed
    OnAtParserResumed()

  case else
    //Do nothing
  endselect
endfunc 1

//Register the following event as late as possible to account for the fact
//that smartBASIC cannot make use of names that have not been declared yet
OnEvent EVMSGAPP                    call HndlrMessageApp

//Detect gap in mux mode 1 between ! characters
OnEvent EVTMR_ESCAPE_DELAY          call HndlrTmrEscSeq

//******************************************************************************
// Start up code from here -equivalent to main() in a 'C' application
//******************************************************************************

//Remove the default pull down on nAutorun pin
rc = GpioSetFunc(SIO_nAUTORUN, SIOTYPE_DIN, INPUT_PULL_NONE)
#cmpif 0x00000003 : AssertRC(64440)

//Start the show
Startup()

//Check if we need to switch to crystal or use internal RC
if (SRegGet(CfgId_HFClockCheckTime_s) != 0) then
    //Enable the temperature check system
    rc = HndlrTempCheck()
    TimerStart(TMRNUM_TEMPERATURE_CHECK, SRegGet(CfgId_HFClockCheckTime_s) * TEMPERATURE_CHECK_TIMER_MUILTIPLYER, 1)
endif

//Install mux_control event handler according to muxmode
select muxMode
case MULTIPLEXER_MODE_GPIO
  //If SReg120 is set to MULTIPLEXER_MODE_GPIO (0), then the sio pin which is
  //specified in SReg121 is used to direct comms exclusively to the Aux Port
  //or into the AT command processor. When input is 0 it is directed to AT
  //command processor
  #cmpif 0x00000004 : DbgMsg("MuxMode 0 handler for MuxCntrl")
  OnEvent EVGPIOCHAN_MUX_CONTROL      call HandlerMux0GpioChng

case MULTIPLEXER_MODE_NONGPIO
  //If SReg120 is set to MULTIPLEXER_MODE_NONGPIO (1), then the sio pin which is
  //specified in SReg121 is used to direct comms such that a lo-hi transition
  //flips the direction and the host can monitor which way it is pointing by
  //monitoring the MUX_STATUS output pin
  #cmpif 0x00000004 : DbgMsg("MuxMode 1 handler for MuxCntrl")
  OnEvent EVGPIOCHAN_MUX_CONTROL      call HandlerMux1GpioChng

case else
  //No event binding
endselect

//If low power UART operation enabled, then start timer
if fLowPwrUrtEnable then
  if GpioRead(lowPowerModePin) == 0 then
    //Start the UART inactivity timer because the host is allowing is to go to sleep
    TimerStart(TMRNUM_LOWPWR_UARTandAUX, uartIdleToutMs, 0)
      #cmpif 0x00000104 :  DbgMsg("Uart Tmr STARTs")
  endif
endif

#cmpif 0x20000000 : sprint #urtTxCache$, rspStart$;"Laird Connectivity Pinnacle 100, AppVer:";AppVer;" LibVer:";LibVer;rspTerm$

//If we came alive because of a reset() call earlier, then send an OK
if sysinfo(2000) == 10 then
  AppendRspEnd(RSP_OK, urtTxCache$)
endif
//Send out data waiting in buffer
UartSendFrom840()

//******************************************************************************
//Wait in a lower-power mode for an event to occur
//******************************************************************************
WAITEVENT

OnAppExit(0)
